<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树</title>
      <link href="/2024/09/14/data_structure/9.14Treee/"/>
      <url>/2024/09/14/data_structure/9.14Treee/</url>
      
        <content type="html"><![CDATA[<p>假设链式存储的二叉树结点定义如下所示。请写出前&#x2F;中&#x2F;后序遍历代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点定义 (链式存储)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;        <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>*<span class="title">lchild</span>,*<span class="title">rchild</span> ;</span>     <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pre</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == Null)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    visit(root);</span><br><span class="line">    pre(root-&gt;lchild);</span><br><span class="line">    pre(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mid</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == Null) <span class="keyword">return</span>;</span><br><span class="line">    mid(root-&gt;lchild);</span><br><span class="line">    visit(root);</span><br><span class="line">    mid(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">houxu</span><span class="params">(BiTree root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == Null) <span class="keyword">return</span>;</span><br><span class="line">    houxv(root-&gt;lchild);</span><br><span class="line">    houxv(root-&gt;rchild);</span><br><span class="line">    visit(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设链式存储的二叉树结点定义如下所示。请写出层序遍历代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点定义 (链式存储)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>*<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>           <span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line">注：可定义数据结构队列Queue 存储二叉树结点。并且可使</span><br><span class="line">用以下基本操作处理队列。</span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(Queue &amp;Q)</span></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(Queue Q)</span></span><br><span class="line"><span class="comment">//新元素入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(Queue &amp;Q, BiTNode *)</span></span><br><span class="line"><span class="comment">//队头元素出队，(并使用×返回队头元素)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(Queue &amp;Q, BiTNode * &amp;x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cengxu</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == Null) <span class="keyword">return</span>;</span><br><span class="line">    Queue q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    Bitree r <span class="comment">//用于接收返回的队头元素</span></span><br><span class="line">    EnQueue(Q,T);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="type">bool</span> IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,r);</span><br><span class="line">        visit(r);</span><br><span class="line">        <span class="keyword">if</span>(r-&gt;lchild != Null) EnQueue(Q,r-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(r-&gt;rchild != Null) EnQueue(Q,r-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设链式存储的二叉树结点定义如下所示。请实现一个函数求树的高度。例如：二叉树<br>旺财的高度&#x3D;3，二叉树喵喵的高度&#x3D;4。规定空二叉树高度&#x3D;0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点定义 (链式存储)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNodef</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;<span class="number">1</span>/数据域</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pre</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">height</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == Null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = height(T-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> r = height(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设链式存储的二叉树结点定义如下所示。请实现代码求二叉树树的宽度。结点最多的一层中，结点数量即为二叉树的宽度。例如：二叉树旺财的宽度=2，二叉树喵喵的宽度=3。规定空二叉树宽度=0。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">width</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == Null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l = width(T-&gt;lchild);</span><br><span class="line">    <span class="type">int</span> r = width(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span>(l+r &gt; max) </span><br><span class="line">    max = l+r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研，算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要背的结构体</title>
      <link href="/2024/09/02/data_structure/jiegouti/"/>
      <url>/2024/09/02/data_structure/jiegouti/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研，算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="/2024/03/05/suanfa/c/2.STL/"/>
      <url>/2024/03/05/suanfa/c/2.STL/</url>
      
        <content type="html"><![CDATA[<h1 id="1-pair"><a href="#1-pair" class="headerlink" title="1. pair"></a>1. pair</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在C++中，pair是一个模板类，用于表示一对值的组合。它位于<utility>头文件中。<br>pair类模板有两个模板参数，<code>T1</code>和<code>T2</code>，分别表示第一个值和第二个值的类型。<br>pair类有两个成员变量，<code>first</code>和<code>second</code>表示第一个值和第二个值。<br>pair类还有一些成员函数和特性，例如默认构造函数、带参数的构造函数、比较运算符重载等。使用pair类，你可以方便地将两个值组合在一起，并进行传递存储和操作例如，可以将两个整数组合在一起作为函数的返回值，或者将一对值存储在容器中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>&#123;</span><br><span class="line">    T1 first;<span class="comment">//第-个值</span></span><br><span class="line">    T2 second;<span class="comment">//第二个值</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">pair</span>();</span><br><span class="line">    pair（<span class="type">const</span> T1&amp; x,<span class="type">const</span> T2&amp; y）;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//比较运算符重载</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==（<span class="type">const</span> pair&amp; rhs)<span class="type">const</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=（<span class="type">const</span> pair&amp; rhs)<span class="type">const</span>;</span><br><span class="line">    <span class="comment">//其他成员函数和特性</span></span><br><span class="line">    <span class="comment">//……</span></span><br></pre></td></tr></table></figure><p>以下是一些使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt;<span class="built_in">p1</span>(<span class="number">1</span>,<span class="number">3.14</span>);</span><br><span class="line">    std::pair&lt;<span class="type">char</span>, std::string&gt;<span class="built_in">p2</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">      </span><br><span class="line">    std::cout&lt;&lt;p1.first&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;p1.second&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;p2.first&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;p2.second&lt;&lt;std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pair的嵌套"><a href="#pair的嵌套" class="headerlink" title="pair的嵌套"></a>pair的嵌套</h2><p>在这个示例中，我们创建了三个pair对象：p1、p2和p3。<br>p1是一个简单的pair，包含两个整数值。<br>p2是一个嵌套的pair，其中第一个值是一个整数，第二个值是一个pair，其中包含两个整数<br>p3是一个嵌套的pair，其中每个值都是一个pair，每个pair包含两个整数值。<br>通过访问嵌套的pair对象的成员变量，我们可以获取到相应的值。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::pair&lt;<span class="type">int</span>,std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">p2</span>(<span class="number">3</span>,std::<span class="built_in">make_pair</span>(<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">    std::pair&lt;std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">p3</span>(std::<span class="built_in">make_pair</span>(<span class="number">6</span>,<span class="number">7</span>),std::<span class="built_in">make_pair</span>(<span class="number">8</span>,<span class="number">9</span>));</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;p1.first&lt;&lt;<span class="string">&quot;，&quot;</span>&lt;&lt;p1.second&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;p2.first&lt;&lt;<span class="string">&quot;，&quot;</span>&lt;&lt;p2.second.first&lt;&lt;<span class="string">&quot;，&quot;</span>&lt;&lt;p2.second.second &lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;p3.first.first&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;p3.first.second&lt;&lt;<span class="string">&quot;，&quot;</span>&lt;&lt;p3.second.first&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;p3.second.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="pair自带排序规则"><a href="#pair自带排序规则" class="headerlink" title="pair自带排序规则"></a>pair自带排序规则</h2><p>pair自带的排序规则是按照<code>first</code>成员进行<code>升序排序</code>。如果first成员相等，则按照second成员进行升序排序。<br>这意味着当你使用标准库中的排序算法（如std:：sort）对包含pair对象的容器进行排序时会根据pair对象的first成员进行排序。<br>需要注意的是，如果你想按照其他排序规则对pair进行排序，可以自定义比较函数或使用lambda表达式来传递给排序算法。这样，你可以根据自己的需求定义排序规则。  </p><h1 id="2-vector"><a href="#2-vector" class="headerlink" title="2. vector"></a>2. vector</h1><p>在C++中，<code>vector</code>是一个动态数组容器，可以存储一系列相同类型的元素。它是标准库<vector>中定义的模板类。<br>容器大小：<code>vector</code>是一个动态数组，可以根据需要自动调整大小。它会根据元素的数量动态分配内存空间<br>元素访问：可以通过索引来访问<code>vector</code>中的元素。索引从0开始，最后一个元素的索引是<code>size()-1</code>。可以使用<code>[]运算符</code>或<code>at()函数</code>来访问元素。<br>元素添加和删除：可以使用<code>push_back</code>（函数在<code>vector</code>的末尾添加元素，使用<code>pop_back</code>（函数删除末尾的元素。还可以使用<code>insert()</code>（函数在指定位置插入元素，使用<code>erase()</code>函数删除指定位置的元素。<br>容器大小管理：可以使用<code>size()</code>函数获取vector中元素的数量，使用<code>empty()</code>函数检查<code>vector</code>否为空。还可以使用<code>resize()</code>函数调整<code>vector</code>的大小。<br>迭代器：vector提供了迭代器，可以用于遍历容器中的元素。可以使用<code>begin()</code>函数获取指向第一个元素的选代器，使用<code>end()</code>函数获取指向最后一个元素之后位置的迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line"></span><br><span class="line">    num.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    num.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    num.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line">    num.<span class="built_in">push_back</span>(<span class="number">5</span>);    </span><br><span class="line">    num.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    num.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    num.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">    num.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原始向量中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; x : num)&#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对向量进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去除重复元素</span></span><br><span class="line">    num.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>()),num.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在向量中插入元素</span></span><br><span class="line">    num.<span class="built_in">insert</span>(num.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除向量中的某个元素</span></span><br><span class="line">    num.<span class="built_in">erase</span>(num.<span class="built_in">begin</span>() + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(num.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; std:endl;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; std:endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取向量大小</span></span><br><span class="line">    std::cout &lt;&lt;<span class="string">&quot;向量大小：&quot;</span>&lt;&lt; num.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空向量</span></span><br><span class="line">    num.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h1><p><code>先进先出FIFO</code>  </p><h2 id="Priority-queue优先队列"><a href="#Priority-queue优先队列" class="headerlink" title="Priority_queue优先队列"></a>Priority_queue优先队列</h2><p><code>priority_queue</code>与普通队列不同，<code>priority_queue</code>中的元素是按照一定的优先级进行排序的。默认情况下，<code>priority_queue</code>按照元素的值<code>从大到小</code>进行排序。<br>常用函数：<br><code>push(x)</code>，<code>O(log2N) </code><br><code>pop(x)</code>，<code>O(log2N)</code><br><code>size()</code>,<code>O(1)  </code><br><code>empty()</code>, <code>O(1)  </code><br><code>top()</code>,<code>O(1) </code></p><h2 id="修改比较函数"><a href="#修改比较函数" class="headerlink" title="修改比较函数"></a>修改比较函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//自定义比较函数，按照逆序排列（原先是less)</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std:;priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>,compare&gt; pq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：如果priority_queue中的元素类型比较简单，可以直接使用greater<T>来修改比较方法(默认是less<T>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p><code>deque</code>（双端队列）是一种容器，它允许在两端进行高效的插入和删除操作。<br><code>deque</code>是由一系列连续的存储块（缓冲区）组成的，每个存储块都存储了多个元素。这使得deque能够在两端进行快速的插入和删除操作，而不需要移动其他元素。<br>常用函数：<br><code>push_back(x)</code>，<code>O(1)   </code><br><code>push_front(x)</code>，<code>O(1)   </code><br><code>pop_back(x)</code>,<code>O(1)</code><br><code>pop_front(x)</code>,<code>O(1)  </code><br><code>front()</code>,<code>back()</code>,<code>size()</code>,<code>empty()</code>,<code>clear()  </code></p><h1 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p><code>set</code>是一种容器，用于存储一组唯一的元素，并按照一定的排序规则进行排序。set中的元素是按照<code>升序</code>排序的，默认情况下，它使用元素的比较运算符<code>(&lt;)</code>来进行排序。<br><code>set</code>的内部实现使用了<code>红黑树</code>(一种自平衡的二叉搜索树)来存储元素，并保持元素的有序性。这使得在<code>set</code>中插入、删除和查找元素的时间复杂度都是对数时间，即<code>o(logn)</code>。<br><code>set</code>中的元素是唯一的，即<code>不允许重复的元素存在</code>。当插入一个重复的元素时，<code>set</code>会自动忽略该元素。<br><code>insert(x)</code>, <code>erase(x)</code>, <code>find(x)</code>, <code>lower_bound(x)</code>, <code>upper_bound(x)</code>, <code>size()</code>, <code>empty()</code>, <code>clear()</code>, <code>begin()</code>, <code>end()</code>, <code>rbegin()</code>, <code>rend()</code></p><p>修改set的常见手段(和priority_queue类似)</p><ol><li>直接修改<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; mySet;</span><br></pre></td></tr></table></figure></li></ol><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MYCompare</span>()&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operater</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a,<span class="type">const</span> <span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//MYCompare成为仿函数</span></span><br><span class="line">    set&lt;<span class="type">int</span>,MYCompare&gt; Myset;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h2><p>与<code>set</code>不同的是，<code>multiset</code>允许<code>存储重复的元素</code><br>注：在<code>multiset</code>中使用<code>erase()</code>会将所有同值元素删除，若只想删一个，需要通过<code>st.erase(st.find(x))</code>，找到该元素的迭代器后删除</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++/h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> tuto&amp; elem : mySet)&#123;</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找元素</span></span><br><span class="line">    <span class="type">int</span> searchValue = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(searchValue);</span><br><span class="line">    <span class="keyword">if</span>(it != mySet.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除元素</span></span><br><span class="line">    <span class="type">int</span> removeValue = <span class="number">2</span>;</span><br><span class="line">    mySet.<span class="built_in">erase</span>(removeValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空集合</span></span><br><span class="line">    mySet.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查空集合</span></span><br><span class="line">    <span class="keyword">if</span>(mySet.empty)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p><code>map</code>是一种关联容器，用于存储一组键值对（<code>key-value pairs</code>），其中每个键（<code>key</code>）都是唯一的。<br><code>map</code>容器根据键来自动进行排序，并且可以通过键快速查找对应的值。<br><code>map</code>容器使用<code>红黑树</code>（Red-BlackTree）数据结构来实现，具有较快的插入、删除和查找操作的时间复杂度<code>O(logn)</code>。  </p><h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2><p><code>insert(key,value)</code>,<code>O(logn)</code>;<br><code>erase(key)</code>,<code>O(logn)</code>;<br><code>find(key)</code>,<code>O(logn)</code>;<br><code>count(key)</code>,<code>O(logn)</code>;多用与判断key是否存在;<br><code>lower_bound()</code>,<code>O(logn)</code>;返回第一个不小于指定元素的位置;<br><code>upper_bound()</code>,<code>O(logn)</code>;返回第一个大于指定元素的位置;  </p><h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><p>multimap是一种关联容器，类似于map，但允许存储多个具有相同键的键值对。<br>multimap容器根据键来自动进行排序，并且可以通过键快速查找对应的值。multimap容器使用红黑树（Red-BlackTree）数据结构来实现，具有较快的插入、删除和查找操作的时间复杂度。  </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>竞赛常用算法</title>
      <link href="/2024/03/02/suanfa/c/1.%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2024/03/02/suanfa/c/1.%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="万能头文件"><a href="#万能头文件" class="headerlink" title="万能头文件"></a>万能头文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="sort-算法"><a href="#sort-算法" class="headerlink" title="sort 算法"></a>sort 算法</h1><p>sort使用的是快排或者类似快排的改进算法，时间复杂度一般为O(nlogn)<br><code>sort(起始地址，结束地址后一位，*比较函数)</code><br>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//读取数组大小</span></span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;=n; i++)</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27;&#x27;;</span></span><br></pre></td></tr></table></figure><p><code>加上比较函数后</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;u, <span class="type">const</span> <span class="type">int</span> &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u &gt; v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化v</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">11</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组进行降序排列</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),cmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">        ocut &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:v) cout &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义lambda表达式</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">11</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//降序排列</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),[](<span class="type">const</span> <span class="type">int</span> &amp;u, <span class="type">const</span> <span class="type">int</span> &amp;v))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> u &gt; v;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span>(autp i:v) cout &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>cout &lt;&lt; a[i] &lt;&lt; endl;: 这行代码会输出数组 a 中索引为 i 的元素，然后在元素后面输出一个换行符，并刷新输出流。换行符会使下一个输出从下一行开始。<br>cout &lt;&lt; a[i] &lt;&lt; ‘ ‘;: 这行代码也会输出数组 a 中索引为 i 的元素，然后在元素后面输出一个空字符。空字符并不会引入换行，所以后续的输出会继续在同一行上。</p></div><p>例：题目描述给定一个长度为N的数组A，请你先从小到大输出它的每个元素，再从大到小输出它的每个元素。<br>(输入描述第一行包含一个整数N。第二行包含N个整数a1,…,an，表示数组A的元素。1≤N≤5e5,-10e9≤a≤ 10e9)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义N和数组</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//降序序列</span></span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i==n];</span><br><span class="line"><span class="comment">//方法1：逆序输出</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">  cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：先改为升序序列再顺序输出</span></span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>, a+<span class="number">1</span>+n, [](<span class="type">const</span> <span class="type">int</span> &amp;u, <span class="type">const</span> <span class="type">int</span> &amp;v)&#123;</span><br><span class="line">    <span class="keyword">return</span> u&gt;v;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i==n];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="min-element-max-element"><a href="#min-element-max-element" class="headerlink" title="min_element &amp; max_element"></a>min_element &amp; max_element</h1><div class="note success flat"><p>min_element（st,ed)返回地址[st,ed)中最小的那个值的地址（迭代器），传入参数为两个地址或迭代器。<br>max_element（st,ed)返回地址[st,ed)中最大的那个值的地址（迭代器），传入参数为两个地址或迭代器。<br>时间复杂度均为0（n），n为数组大小（由传入的参数决定）  </p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">11</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出最大的元素，通过*解引用，即通过地址（迭代器）得到值</span></span><br><span class="line">cout &lt;&lt; *<span class="built_in">max_element</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>nth_element(st, k, ed)进行部分排序，返回值为void()<br>传入参数为三个地址或迭代器。其中第二个参数位置的元素将处于正确位置，其他位置元素的顺序可能是任意的，但前面的都比它小，后面的都比它大。<br>时间复杂度O（n）</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">18</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">nth_element</span>(v.begin, v.begin + <span class="number">3</span>,v.end);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i :v) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">//输出3 1 5 7 9 18 10，其中v[3]的位置是排序后的结果</span></span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><code>库函数只能对数组进行二分查找，且数组元素必须是单调的，一般为单调不减（单调递增需要修改比较函数）</code>   </p><ol><li>binary_search<br>它通过二分查找算法来确定序列中是否存在目标元素。函数返回一个bool值，表示目标元素是否存在于序列中。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> target = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用binary_search 查找目标元素</span></span><br><span class="line"><span class="type">bool</span> foune = <span class="built_in">binary_search</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), target);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(found)&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Target element&quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot;found&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Target element&quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>lower_bound &amp; upper_bound<br>注：<code>元素地址-首地址则为数组下标</code><br>lower_bound(st，ed,x）返回地址[st,ed）中第一个大于等于x的元素的<code>地址</code>。<br>upper_bound（st,ed，x）返回地址[st,ed)中第一个大于x的元素的<code>地址</code>。<br>如果不存在则返回最后一个元素的下一个位置。<br>在vector中即end()  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化v</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">18</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : v) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到数组中第一个大于等于8的元素的位置</span></span><br><span class="line">cout &lt;&lt; (<span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">8</span>) - v.<span class="built_in">begin</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>例题：<a href="https://www.lanqiao.cn/problems/1389/learning/?page=1&first_category_id=1&name=%E4%BA%8C%E5%88%86">二分数组查找元素</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> data[<span class="number">200</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">200</span> ; i ++) data[i] = <span class="number">4</span> * i + <span class="number">6</span>;</span><br><span class="line">  <span class="type">int</span> target; cin &gt;&gt; target;</span><br><span class="line">  cout &lt;&lt; (<span class="built_in">lower_bound</span>(data, data + <span class="number">200</span>, target) - data) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h1><ol><li>islower&#x2F;isupper函数<br>  判断大小写字符，但是无法判断特殊字符（返回bool）  </li><li>tolower&#x2F;toupper函数<br>  tolower(char ch)可以将ch转换为小写字母，如果ch不是大写字母则不进行操作。<br>  toupper同理  </li><li>ASCII码<br>  将c转为C：’c’-‘a’+’A’&#x3D; ‘C’<br>例：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;btis/C++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> name std;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">convertedCh</span><span class="params">(<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">islower</span>(ch))ch = <span class="built_in">toupper</span>(ch);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">is</span>(<span class="built_in">isupper</span>(ch)ch) = <span class="built_in">tolower</span>(ch);</span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  string s; getline(cin, s);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : s)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    i = convertedCh(i);</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">  cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">return</span> <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure></li></ol><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p><code>next_permutation &amp; pre_permutation</code><br>   <code>next_permutation</code>函数用于生成当前序列的下一个排列。它按照字典序对序列进行重新排列，如果存在下一个排列，则将当前序列更改为下一个排列，并返回true；如果当前序列已经是最后一个排列，则将序列更改为第一个排列，并返回false。<br>   <code>pre_permutation</code>则相反，将生成当前序列的上一个排列，若当前序列已是第一个序列，则将序列更改为最后一个排列。  </p><h1 id="其他库函数"><a href="#其他库函数" class="headerlink" title="其他库函数"></a>其他库函数</h1><ol><li>memset()<br> memset()函数接受三个参数：1.ptr：指向要设置值的内存块的指针 2.value：要设置的值，通常是一个整数 3.num：要设置的字节数。<br> memset()函数将ptr指向的内存块的前num个字节设置为value的值。它返回个指向ptr的指针。  memset(）函数通常用于初始化内存块，将其设置为特定的值。例如，如果要将一个整型数组的所有元素设置为0，可以使用memset(）函数如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];<span class="built_in">memset</span>(arr,,<span class="keyword">sizeof</span>（arr));</span><br></pre></td></tr></table></figure></li><li>swap()<br>swap（T&amp;a，T&amp;b）函数接受两个参数<br>1.a：要交换值的第一个变量的引用。<br>2.b：要交换值的第二个变量的引用。<br>swap()函数通过将第一个变量的值存储到临时变量中，然后将第二个变量的值赋给第一个变量，最后将临时变量的值赋给第二个变量，实现两个变量值的交换。  </li><li>reverse()<br>reverse()函数接受两个参数：<br>1.first：指向容器中要反转的第一个元素的迭代器<br>2.last：指向容器中要反转的最后一个元素的下一个位置的迭代器。<br>reverse（）函数将[first，last）范围内的元素顺序进行反转。也就是说，它会将[first，last)范围内的元素按相反的顺序重新排列。<br><code>reverse()函数可用于反转各种类型的容器，包括数组、向量、链表等。</code><br><code>注：reverse()只能用于支持双向迭代器的容器</code>   </li><li>unique()<br> unique（first,last)函数接受两个参数：<br> 1.first：指向容器中要去重的第一个元素的迭代器。<br> 2.last：指向容器中要去重的最后一个元素的下一个位置的迭代器。<br><code> 注：它并不会删除数组中的元素，而是返回指向新的“逻辑尾部”的迭代器，该迭代器之前的元素序列是不重复的。</code><br> unique()函数将[first，last）范围内的相邻重复元素去除，并返回一个指向去重后范围的尾后迭代器。去重后的范围中只保留了第一个出现的元素，后续重复的元素都被移除。<br> unique()函数可用于去除各种类型的容器中的相邻重复元素，包括数组、向量、链表等。以下是一个示例，展示如何使用unique（）函数去除一个整型向量中的相邻重复元素：</li></ol> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"> <span class="keyword">auto</span> it = std ::<span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"> <span class="comment">//将指向重复元素的部分的末尾迭代器返回，并将其赋值给it，这样it指向的位置就是不重复的元素的末尾。</span></span><br><span class="line"></span><br><span class="line"> vec.<span class="built_in">erase</span>(it, vec.<span class="built_in">end</span>());</span><br><span class="line"> <span class="comment">//删除从it指向的位置开始到vec的末尾范围内的元素，这样就将重复的元素删除了。</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> num : vec) &#123;</span><br><span class="line">   std::cout &lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们在南昌的故事</title>
      <link href="/2024/02/09/richang/nanchang/"/>
      <url>/2024/02/09/richang/nanchang/</url>
      
        <content type="html"><![CDATA[<h1 id="这几天是我特别快乐的一段时光"><a href="#这几天是我特别快乐的一段时光" class="headerlink" title="这几天是我特别快乐的一段时光"></a>这几天是我特别快乐的一段时光</h1><p>&ensp;&ensp;&ensp;&ensp;对我而言，我们的相遇真的好幸福。<br>&ensp;&ensp;&ensp;&ensp;在这几天里，我真的非常非常开心！<code>这几天是我人生中有特别特别意义的几天。</code>  </p><div style="display: flex;">    <img src="https://pic.imgdb.cn/item/65b1fd45871b83018a97fac6.jpg"  style="flex: 1;" width=70%></div><h1 id="“那一天那一刻那个场景”"><a href="#“那一天那一刻那个场景”" class="headerlink" title="“那一天那一刻那个场景”"></a>“那一天那一刻那个场景”</h1><p>&ensp;&ensp;&ensp;&ensp;从我们在你的学校相遇开始，去看<code>湖</code>，看<code>孔雀</code>，去看<code>“椰子树”</code>，你们的<code>温室</code>，<code>图书馆</code>，<code>教学楼</code>。我们聊了好多好多.然后去吃午饭，吃<code>茄子</code>和<code>甲鱼</code>，感觉这一顿真的特别好吃！之后又因为我“没有安全感”，还特意跑回学校拿包。<br>&ensp;&ensp;&ensp;&ensp;然后我们去<code>南昌之星</code>，喂了<code>鸽子</code>，坐了亚洲最高的摩天轮，去万达去万象城。有一种我们走了好远好远的感觉，有的路灯光微暗，有点吓人，但是大多数地方还是灯火通明，热热闹闹的😋。<br>&ensp;&ensp;&ensp;&ensp;这天我们被老三样折腾了好久，晚上还是选择了<code>烤肉</code>！我们一路上真的聊了好多好多，<code>这是我好喜欢的氛围和感觉</code>。 </p><div style="text-align: center;"><img src="https://pic.imgdb.cn/item/65c604d59f345e8d03952d32.jpg" alt="Oi22bX.jpg" width=80%></div>   <p>&ensp;&ensp;&ensp;&ensp;相处了一段时间之后，我感觉你身上有一种公主的气质hhh（也不知道这样形容合不合适），是那种<code>漂亮里带着明媚和美好</code>的感觉！第二天我觉得，你匆匆忙忙收拾完行李来陪我去玩，但因为我拍照太烂了，反倒闹的不那么愉快。我也能明白，每个人认认真真打扮出来玩，理所应当要拍一些漂漂亮亮的照片😭我自己也自责了好久，真的很抱歉！！虽然我们只是第一次见，但也因为是第一次见，我真的担心会因为我的一些什么问题让你讨厌我，因为对我来说真的的是一段非常非常快乐的时光！</p><div style="text-align: center;"><img src="https://pic.imgdb.cn/item/65c604db9f345e8d039539ff.jpg" alt="Oi22bX.jpg" width=80%></div><h1 id="意外的雪景"><a href="#意外的雪景" class="headerlink" title="意外的雪景"></a>意外的雪景</h1><p>&ensp;&ensp;&ensp;&ensp;第三天意外的一场大雪打乱了我们的一些计划，但是真的没想到会下这么大雪，有的地方变得好漂亮！又意外的吃上了老三样😋，真的太幸运了！虽然下午又被酒店坑了，风雪好大又好冷，还好晚上的酒店好棒！还有我们充满曲折的车票（可恶）</p><div style="display: flex;">    <img src="https://pic.imgdb.cn/item/65c6027b9f345e8d03906b12.jpg"  style="flex: 1;" width=90%>    <img src="https://pic.imgdb.cn/item/65c6027b9f345e8d03906b75.jpg"  style="flex: 1;" width=90%></div><h1 id="Ending"><a href="#Ending" class="headerlink" title="Ending"></a>Ending</h1><p>&ensp;&ensp;&ensp;&ensp;村上春树的一句话是：“你要记得那些黑暗中默默抱紧你的人，逗你笑的人，陪你彻夜聊天的人，带着你四处游荡的人，说想念你的人。是这些人组成你生命中一点一滴的温暖，是这些温暖使你成为善良的人。”我们相遇的这段时间里，我真的有太多太多的感动，你为了陪我玩要改签，要额外定酒店，又累人还要破费，还有好多好多。我觉得好的朋友好的爱人都是非常珍贵的礼物，我能够很深刻地感受到爱意和真诚，谢谢你在我们相遇的这段时间里，让我感受到这份美好与温柔。是朋友，是好朋友，是彼此青春的收藏家，是彼此某段时间的精神支柱，永远感谢能被朋友温柔地爱着。<br>&ensp;&ensp;&ensp;&ensp;不见面的日子也要记得好好生活！希望你可以一直明媚温暖，开心快乐，能谈健康幸福的恋爱，也希望我们各自未来一定会以更好的样子相见。如果有不开心或者要帮忙的时候，不要忘记可以找我～最后，希望陈荟一定要平安，快乐，发财，被爱，好运常在，万事胜意，岁岁年年！</p><div style="display: flex;">    <img src="https://pic.imgdb.cn/item/65c6079e9f345e8d039bfd86.jpg"  style="flex: 1;" width=90%>    <img src="https://pic.imgdb.cn/item/65c6079f9f345e8d039bffe1.jpg"  style="flex: 1;" width=90%></div><div class="aplayer no-destroy" data-id="2070770278" data-server="netease" data-type="song" data-fixed="true" data-autoplay="true"> </div><!-- <div class="aplayer no-destroy" data-id="7083530814" data-server="tencent" data-type="playlist" data-fixed="true" data-autoplay="true"> </div> -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++3</title>
      <link href="/2023/11/24/suanfa/c/C++3/"/>
      <url>/2023/11/24/suanfa/c/C++3/</url>
      
        <content type="html"><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体：类似于<code>类</code>，但是没有作用域的修饰符，一般只写属性，但是写方法也不报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">abc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="built_in">abc</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">abc</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">a</span>(a),<span class="built_in">b</span>(b)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">abc <span class="title">asd</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; asd.a &lt;&lt; <span class="string">&quot;||&quot;</span> &lt;&lt; asd.b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p><code>指针</code>是一种<code>用来存储内存地址</code>的特殊的复合类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">string name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">getArr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//指针 是一种特殊的复合类型</span></span><br><span class="line"><span class="comment">//用来存储内存地址的</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr = <span class="built_in">getArr</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//new 完的东西，返回的是一个内存地址，所以要用指针存储</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">Person* p = <span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针存储的内存地址</span></span><br><span class="line"><span class="comment">//用解应用的方式 可以直接对这块连续的内存单元进行操作</span></span><br><span class="line">Person* p = <span class="keyword">new</span> Person;</span><br><span class="line">(*p).age = <span class="number">10</span>;<span class="comment">//代表连续的内存单元本体</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型的定义与使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其中在定义Person类时，定义结束时需要加&quot;;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">maxA</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">C</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C data;</span><br><span class="line"><span class="built_in">Person</span>(C data)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//若我们的类型明确，T则会自动转换该类型</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">maxA</span>(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">maxA</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//也可以自己提前确定数据类型</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">maxA</span>&lt;<span class="type">double</span>&gt;(<span class="number">20.6</span>,<span class="number">12.0</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person&lt;<span class="type">int</span>&gt; *p = <span class="keyword">new</span> <span class="built_in">Person</span>&lt;<span class="type">int</span>&gt;(<span class="number">210</span>);</span><br><span class="line">Person&lt;<span class="type">int</span>&gt; p2;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h1><div class="note success flat"><p>万能的导入语句：<code>#include &lt;bits/stdc++.h&gt;</code></p></div><div class="note success flat"><p><code>unique</code>去重函数,去重后会返回给你一个间断点的位置。</p></div><h2 id="vector向量容器"><a href="#vector向量容器" class="headerlink" title="vector向量容器"></a>vector向量容器</h2><p><code>vector向量</code>与<code>数组</code>十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求，简单来说<code>vector</code>是一个<code>可拓展的一个数组</code>，他的底层就是数组。<br>vector向量的<code>方法</code>:  </p><ol><li><code>push_back()</code>：类似于栈的push，成员函数在向量的末尾插入值，如果有必要会扩展向量的大小</li><li><code>resize()</code>：resize 但是要注意：<strong>重新定义大小，若是空间减少了，会自动删除后面多出的部分</strong></li><li><code>size()</code>：函数显示向量的大小。</li><li><code>begin()</code>：函数返回一个指向向量开头的迭代器。</li><li><code>end()</code>：函数返回一个指向向量末尾的迭代器。</li><li><code>front()</code>：取头元素</li><li><code>back()</code>：取尾元素</li><li><code>clear()</code>：消除所有元素</li><li><code>insert()</code>：直接插入到你提供的位置<br>10.<code>erase()</code>：删除某个范围的元素</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//standard标准 所有的标准库，std</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//可拓展的一个数组，他的底层就是数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//容量不够大，自动扩容</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新定义大小，会删除后面多出的部分</span></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">front</span>();<span class="comment">//取头元素</span></span><br><span class="line">v.<span class="built_in">back</span>();<span class="comment">//取尾元素</span></span><br><span class="line">v.<span class="built_in">clear</span>();<span class="comment">//消除所有元素</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">5</span>);<span class="comment">//直接插入到你提供的位置</span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>() - <span class="number">2</span>);<span class="comment">//删除某个范围的元素</span></span><br><span class="line"><span class="comment">//删除[  v.began(), v.end()-2 )区间内所有元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;p!=v.<span class="built_in">end</span>();p++)&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt;= v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">cout &lt;&lt; v[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unique去重函数,去重后会返回给你一个间断点的位置</span></span><br><span class="line"><span class="comment">//1122223344-&gt;1234 122234</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">v1.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>()),v1.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。简单来说：迭代器的原理是内存地址，用来找容器内的元素。因为在数据结构中，链式结构，数和图都不连续，所以无法用简单的偏移方式进行计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator p = v.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; *(p+<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *(v.<span class="built_in">end</span>()) &lt;&lt; endl;<span class="comment">//尾迭代器没有值</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(;p!=v.<span class="built_in">end</span>();p++)&#123;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p><code>set</code>容器可用于存储键值对，而与我们下文即将提到的map系列不同，set存储的键值对，要求键 key 和值 value 必须相等</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++2</title>
      <link href="/2023/11/23/suanfa/c/C++2/"/>
      <url>/2023/11/23/suanfa/c/C++2/</url>
      
        <content type="html"><![CDATA[<h1 id="函数与static静态修饰符"><a href="#函数与static静态修饰符" class="headerlink" title="函数与static静态修饰符"></a>函数与static静态修饰符</h1><p>函数的定义与声明总体来说与C语言是非常相似的<br>函数中的参数是形式参数，而主函数传入其中的是实际参数  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数的声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的定义与实现</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>  a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SWAP</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span>&#123;      </span><br><span class="line"><span class="comment">//形参：我们接受来源于外部实参的值，并且我们开辟一块空间，用临时变量吧这个值存储起来。 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认参数，默认参数只能放在正常参数的后面</span></span><br><span class="line"><span class="comment">//如不存在正常参数，全是默认参数，也是不会报错的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>,<span class="type">int</span> b = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认参数的输出(main函数中)</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f3</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数的嵌套，本质上就是函数的调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我被调用了&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>static静态修饰符：生命周期长，且具有唯一性  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static特征</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trystatic</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sta = <span class="number">0</span>;</span><br><span class="line">sta++;</span><br><span class="line">cout &lt;&lt; sta &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只要被调用，该变量永远不会消失，生命周期很长,且被static修饰的变量只能存在一个</span></span><br><span class="line">    <span class="built_in">trystatic</span>();<span class="comment">//sta为1</span></span><br><span class="line">    <span class="built_in">trystatic</span>();<span class="comment">//sta为2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="作用域符号-与namespace声明的一块命名空间"><a href="#作用域符号-与namespace声明的一块命名空间" class="headerlink" title="作用域符号::与namespace声明的一块命名空间"></a>作用域符号::与namespace声明的一块命名空间</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> mySpace&#123;</span><br><span class="line"><span class="type">int</span> s1;</span><br><span class="line"><span class="type">int</span> s2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//::作用域符号</span></span><br><span class="line"><span class="type">int</span> s1 = <span class="number">20</span>;</span><br><span class="line">mySpace::s1 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; mySpace::s1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="class类与方法"><a href="#class类与方法" class="headerlink" title="class类与方法"></a>class类与方法</h1><p>类的定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中添加<code>private</code>,<code>public</code>,<code>static</code> 修饰符和对应的属性，和方法的使用  </p><ol><li><code>public</code>修饰的变量为公共变量，而<code>private</code>修饰的变量不能在外部函数直接调用 </li><li>而<code>static</code>声明的事物属于类本身，与以上两个关键字不同，必须用<code>类名::</code>调用，对<code>static</code>属性进行赋值，只能在<code>全局</code>通过<code>作用域符号</code>进行声明，这是一种固定形式</li><li><code>static</code>函数也与其他函数不同，非<code>static</code>的属性和方法不能写在<code>static</code>方法内  </li><li>类为空的时候，实际上存在 无参构造函数  </li><li><code>this</code> 关键字用于代指对象本体</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static声明的事物属于类本身，用类名::调用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> aa;</span><br><span class="line"></span><br><span class="line"><span class="comment">//private不能在外部函数直接调用</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string smallName;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> gander;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot;正在吃饭&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//static函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticaa</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//非static的属性和方法不能写在static方法内</span></span><br><span class="line">cout &lt;&lt; aa &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//this 关键字用于代指对象本体</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setsmallName</span><span class="params">(string name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;smallName = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">getsmallName</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;smallName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">//类为空的时候，实际上存在 无参构造函数</span></span><br><span class="line"><span class="built_in">Animal</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对static属性进行赋值，只能在全局通过作用域符号进行声明，这是一种固定形式</span></span><br><span class="line"><span class="type">int</span> Person::aa = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static修饰的方法可以被对象进行直接调用</span></span><br><span class="line">    p1.<span class="built_in">staticaa</span>();</span><br><span class="line"><span class="comment">//调用static对象</span></span><br><span class="line">cout &lt;&lt; Person::aa &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写完有参构造后，无参构造将会自动被覆盖，由于主函数调用了无参构造方法，所以这里必须重新定于无参构造方法</span></span><br><span class="line"><span class="built_in">Person</span>(string name)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法的销毁</span></span><br><span class="line">~<span class="built_in">Person</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">&quot;已被释放&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算:"></a>位运算:</h1><ol><li>按位与：对每一位进行逻辑与运算</li><li>按位或：对每一位进行逻辑或运算</li><li>按位取反：~</li><li>异或运算：^</li><li>左移右移&lt;&lt; &gt;&gt;</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line">cout &lt;&lt; (a &gt;&gt; <span class="number">2</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h1 id="对象的实例化方式"><a href="#对象的实例化方式" class="headerlink" title="对象的实例化方式"></a>对象的实例化方式</h1><p>有两种方式实例化对象，一种是new，另一种是直接声明一个变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针形式，通过new的方式申请</span></span><br><span class="line">Person* p = <span class="keyword">new</span> <span class="built_in">Person</span>();  </span><br><span class="line"></span><br><span class="line">p-&gt;name = <span class="string">&quot;sdsa &quot;</span>;</span><br><span class="line">cout &lt;&lt; p-&gt;name &lt;&lt; endl;</span><br><span class="line">p-&gt;<span class="built_in">eat</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接声明的方式实例化调用</span></span><br><span class="line">    Person p1;</span><br><span class="line">p1.name = <span class="string">&quot;直接声明的方式实例化调用&quot;</span>;</span><br><span class="line">p1.<span class="built_in">setsmallName</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">cout &lt;&lt; p1.<span class="built_in">getsmallName</span>() &lt;&lt;endl;</span><br><span class="line"><span class="comment">//面向对象的三大特性之一：封装性，私有化的过程用公开的方式调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Person* p2 = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;niubi&quot;</span>);<span class="comment">//有参构造函数</span></span><br><span class="line">cout &lt;&lt; p2-&gt;name &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//new 出来的对象必须主动释放</span></span><br><span class="line"><span class="comment">//调用析构函数主动释放</span></span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组的创建已删除</span></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1111</span>];</span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++(一)</title>
      <link href="/2023/11/16/suanfa/c/new-cpp/"/>
      <url>/2023/11/16/suanfa/c/new-cpp/</url>
      
        <content type="html"><![CDATA[<h1 id="今天开始学C-，之后算法转为用C-来写"><a href="#今天开始学C-，之后算法转为用C-来写" class="headerlink" title="今天开始学C++，之后算法转为用C++来写"></a>今天开始学C++，之后算法转为用C++来写</h1><p>学习网址：<a href="https://www.bilibili.com/video/BV1ZU4y1D7PL?p=2&spm_id_from=pageDriver&vd_source=266ee3c29bce94c83459e67a8a837112">https://www.bilibili.com/video/BV1ZU4y1D7PL?p=2&amp;spm_id_from=pageDriver&amp;vd_source=266ee3c29bce94c83459e67a8a837112</a><br>&emsp;&emsp;由于我已经有一些C语言以及java语言基础，而C++和java语言类似，都是面向对象编程，所以有一些基础我已经掌握到的语法我就不再重新写了，现在更新的是一些不熟的以及没接触过的内容。</p><h2 id="头文件的引入以及代码格式"><a href="#头文件的引入以及代码格式" class="headerlink" title="头文件的引入以及代码格式"></a>头文件的引入以及代码格式</h2><p>和C语言稍有不同但总体大差不差，但是到后期C++在导入库的时候因为有大量的库所以会有很多<code>include</code>语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据的输入输出与数组的定义"><a href="#数据的输入输出与数组的定义" class="headerlink" title="数据的输入输出与数组的定义"></a>数据的输入输出与数组的定义</h2><p>数据的输入用<code>cin</code>和<code>&gt;&gt;</code>表示，输出用<code>cout</code>,<code>&lt;&lt;</code>,和<code>endl</code>表示。<br>一种数组的定义方式：<code>int *arr = new int[n];</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数据以及输入输出</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我刚刚输入的数字是 &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; ||我刚刚输入的字母是&quot;</span> &lt;&lt;  b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是循环语句</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="comment">//数组的定义</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~~~~~~~~~&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逻辑表达式与类型转换"><a href="#逻辑表达式与类型转换" class="headerlink" title="逻辑表达式与类型转换"></a>逻辑表达式与类型转换</h2><p>主要是熟悉逻辑表达式与类型转换，和Java一样分为强制转换和自动转换（隐式转换），自动转换的条件为：<em><strong>1.小的字节范围转到大的字节范围 2. 前后类型不一致则会直接触发</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//逻辑表达式</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;判断的结果是：&quot;</span> &lt;&lt; ((<span class="number">2</span> &lt; <span class="number">3</span>) &amp;&amp; (<span class="number">3</span> &gt; <span class="number">5</span>)) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;判断的结果是：&quot;</span> &lt;&lt; !(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">a++;<span class="comment">//后增a = a + 1</span></span><br><span class="line">++a;<span class="comment">//前增a = a + 1</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a++&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ++a &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动转换机制 （隐式转换）</span></span><br><span class="line"><span class="comment">//触发条件：1.小的字节范围转到大的字节范围 2. 前后类型不一致则会直接触发</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="number">5.0</span>/<span class="number">2</span> &lt;&lt; endl;<span class="comment">//1. 被转换成5.0/2.0</span></span><br><span class="line"><span class="type">int</span> p  = <span class="number">5.0</span>;         <span class="comment">//2. 前后类型不一致则会直接触发</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显式强制类型转换</span></span><br><span class="line"><span class="type">char</span> q =(<span class="type">char</span>)<span class="number">1</span>; </span><br><span class="line">cout &lt;&lt; q &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="数组的声明与部分方法"><a href="#数组的声明与部分方法" class="headerlink" title="数组的声明与部分方法"></a>数组的声明与部分方法</h2><p>数组的声明有两种方式，分别为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">//声明一组字符数组，被称为字符串</span></span><br><span class="line"><span class="comment">//字符数组必须以\0 作为 结束的标识符来声明，没有手动添加时会自动加上去</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;123456&quot;</span>;<span class="comment">//这种方式初始化，会默认在末尾加上\0，此数组字长度为7</span></span><br></pre></td></tr></table></figure><p>C语言和C++的一些输入输出方式(此处使用的是上述声明的数组)。<br><code>getline()</code>方法可以读入空格，而<code>cin</code>不行，这是因为<code>cin</code>是输入流，在其中空格的作用和回车一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="built_in">scanf</span>(str);</span><br><span class="line"><span class="built_in">gets</span>(str);</span><br><span class="line"><span class="built_in">fgets</span>(str,<span class="number">2</span>,stdin);<span class="comment">//stdin 是你要读取的输入文件</span></span><br><span class="line"><span class="comment">//cpp</span></span><br><span class="line">cin.<span class="built_in">getline</span>(str,<span class="number">2</span>);</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; str + <span class="number">2</span> &lt;&lt;endl;<span class="comment">//此时输出的是：3456</span></span><br><span class="line"><span class="comment">//字符数组可以根据内存地址直接从头到尾输出</span></span><br></pre></td></tr></table></figure><p>一些和数组有关的函数，这里主要涉及3个，分别为：比较：<code>strcmp()</code>,拷贝：<code>strcpy()</code>,拼接：<code>strcat()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">char</span> b[] = <span class="string">&quot;45&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当对象是数字时，比较首个数字大小；当对象是字符时，比较ASCII</span></span><br><span class="line"><span class="type">int</span> c = <span class="built_in">strcmp</span>(a,b);</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝</span></span><br><span class="line"><span class="built_in">strcpy</span>(a,b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拼接</span></span><br><span class="line"><span class="built_in">strcat</span>(a,b);<span class="comment">//strcat有自动扩容功能</span></span><br></pre></td></tr></table></figure><h2 id="string字符与部分方法"><a href="#string字符与部分方法" class="headerlink" title="string字符与部分方法"></a>string字符与部分方法</h2><p>string类型的三种初始化方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string arr = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="number">5</span>,<span class="string">&#x27;a&#x27;</span>)</span></span>;<span class="comment">//单个字符重复录入</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;there&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>string的拼接：用+号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">a = <span class="string">&quot;pre&quot;</span> + a + <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure><p>string的输入输出只能通过<code>cin</code>和<code>cout</code>实现，这里再次提及了上文出现过的<code>getline()</code>方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin,str);<span class="comment">//可以读空格，cin是输入流</span></span><br><span class="line">cin &gt;&gt; str;<span class="comment">//空格的作用回车一样</span></span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>string相关的方法:<br>判断是否为空：<code>str.empty()</code><br>判断长度：<code>str.size()</code>;&amp;<code>str.length();</code><br>修改替换：<code>str.replace()</code>,需要注意格式与写法<br>删除：<code>str.erase()</code>,需要注意格式与写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">string arr = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str.<span class="built_in">empty</span>(); <span class="comment">//判断是否为空 </span></span><br><span class="line"><span class="comment">//两个函数都是读取长度，功能一样。</span></span><br><span class="line">str.<span class="built_in">size</span>();</span><br><span class="line">str.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;改&quot;和&quot;删&quot;方法，都是（起始位置，长度）</span></span><br><span class="line"></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;ABCD&quot;</span>,<span class="number">2</span>,<span class="number">2</span>);    <span class="comment">// 结果：12CD6</span></span><br><span class="line"><span class="comment">//(起始位置，替换长度，替换字符，替换字符的起始位置，替换字符的长度)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除方法</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">3</span>);    <span class="comment">//结果：123</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">3</span>,<span class="number">1</span>);  <span class="comment">//结果：12356 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note success flat"><p>string是特殊的数据结构，是STL容器中的一员</p></div><p><mark>string的层实现原理就是 字符数组</mark>，因此可以使用下标对string直接进行操作。<br>并且字符串的比较，<mark>可以直接使用大于小于</mark>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl;  <span class="comment">//结果：2</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;A&#x27;</span>;  <span class="comment">//结果：1A3456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">string b = <span class="string">&quot;234&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cout &lt;&lt; </span><br><span class="line"><span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;    <span class="comment">//结果:0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="string与其他类型的互相转换"><a href="#string与其他类型的互相转换" class="headerlink" title="string与其他类型的互相转换"></a>string与其他类型的互相转换</h2><ol><li><p>字符数组可以直接转变为string类型 </p></li><li><p>string无法直接转为字符数组，只能转为 const char[]，也就是const char*</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> hh[] = <span class="string">&quot;哈哈&quot;</span>;</span><br><span class="line">string ssss = hh;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.string无法直接转为字符数组，只能转为 const char[]，也就是const char*</span></span><br><span class="line"><span class="type">char</span>* p = (<span class="type">char</span>*)ssss.<span class="built_in">c_str</span>();</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li><p>其他类型数据和字符串的相互转换,通过<code>istringstream</code>和<code>ostringstream</code>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1. 字符串转换为变量</span></span><br><span class="line"><span class="function">string <span class="title">src</span><span class="params">(<span class="string">&quot;hello 123 4.5 T&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">istringstream <span class="title">is</span><span class="params">(src)</span></span>; <span class="comment">/*建立一个字符串的输入流*/</span></span><br><span class="line"></span><br><span class="line">string s1;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">double</span> b;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">is &gt;&gt; s1 &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 变量转换为字符串</span></span><br><span class="line">ostringstream os;</span><br><span class="line">os &lt;&lt; s1 &lt;&lt; <span class="string">&quot;哈哈&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c;</span><br><span class="line">cout &lt;&lt; os.<span class="built_in">str</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ol><h2 id="增强型for语句-for-each-，自适应关键字auto，引用符号"><a href="#增强型for语句-for-each-，自适应关键字auto，引用符号" class="headerlink" title="增强型for语句(for each)，自适应关键字auto，引用符号&amp;"></a>增强型for语句(for each)，自适应关键字auto，引用符号&amp;</h2><p>增强型for语句(for each)：用于快速遍历<br>自适应关键字auto：类似于java中的var，当期遇到一串字符，类似与<code>hello world</code>时，会自动转换为char而不是string类型<br><code>&amp;</code> 引用符号：共享同一块空间，俗称取别名(可以借此修改for each源码)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for each</span></span><br><span class="line"><span class="comment">//首先要有一个 待输出的变量，用来装每个需要遍历的元素</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x : arr)&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自适应关键字 auto ，和java中的var类似</span></span><br><span class="line"><span class="keyword">auto</span> at1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : at1)&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> at2 = <span class="string">&quot;hello world&quot;</span>;<span class="comment">//auto默认char类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp; 引用符号：共享同一块空间，俗称取别名</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>&amp; n = m;<span class="comment">//别名，小名</span></span><br><span class="line">n = <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line"><span class="comment">//用于修改for each源码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : arr)&#123;</span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : arr)&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码如下</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line"><span class="type">int</span> x = arr[i];</span><br><span class="line">x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四六级复习——作文翻译</title>
      <link href="/2023/11/10/English/%E5%9B%9B%E5%85%AD%E7%BA%A7%E5%A4%8D%E4%B9%A0-1/"/>
      <url>/2023/11/10/English/%E5%9B%9B%E5%85%AD%E7%BA%A7%E5%A4%8D%E4%B9%A0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="作文-翻译"><a href="#作文-翻译" class="headerlink" title="作文&amp;翻译"></a>作文&amp;翻译</h1><h2 id="1-简单句"><a href="#1-简单句" class="headerlink" title="1. 简单句"></a>1. 简单句</h2><h2 id="2-被动句：①没有主语时-②人-许多人-越来越多人-等人或人称代词作主语时考虑写成被动"><a href="#2-被动句：①没有主语时-②人-许多人-越来越多人-等人或人称代词作主语时考虑写成被动" class="headerlink" title="2. 被动句：①没有主语时 ②人&#x2F;许多人&#x2F;越来越多人 等人或人称代词作主语时考虑写成被动"></a>2. 被动句：①没有主语时 ②人&#x2F;许多人&#x2F;越来越多人 等人或人称代词作主语时考虑写成被动</h2><p><em><strong>很多人认为盲目追星这个问题已经很严重了</strong></em><br>Pursuing stars has been claimed to be more and more serious by many people nowadays.</p><p><em><strong>越来越多人认为，终身学习已经成为他们成长的一部分</strong></em><br>Long life learning has been argued to be a prat of growth by an incresing number of adults.</p><p><em><strong>正是通过丝绸之路，中国的造纸，火药，指南针，印刷术四大发明才被引介到世界各地，同样，中国的丝绸，茶叶和瓷器也传遍全球</strong></em><br>It was through the silk road that China’s four great inventions such as Paper making, Gunpowder, Compass and painting were introduced to other parts of the world. Likewise, China’s silk, tea and Procelain also spend around the world. </p><p><em><strong>中国许多地方都培育和种植牡丹。千百年来，创作了许多诗歌和绘画赞美牡丹。唐代时期，牡丹在皇家园林普遍种植并被誉为国花，因而特别风行</strong></em><br>Peony has been cultivated and planted in many parts of China. For thousands of years, many poem and painting was created to praise Peony. During the Tang Dynasty, Peony was planted widly in royal gardens and known as the national flower, so it was especially popular.</p><p><em><strong>很多中国新娘也会选旗袍作为结婚礼服。一些有影响的人士甚至建议将旗袍作为中国女性的民族服饰</strong></em><br>Qipao is also chosen by brides as their wedding dress, and it is suggested by some influencial people to be the national dress for Chinese women.  </p><h2 id="3-并列句：上下句有逻辑关系，必须加逻辑关系词"><a href="#3-并列句：上下句有逻辑关系，必须加逻辑关系词" class="headerlink" title="3. 并列句：上下句有逻辑关系，必须加逻辑关系词"></a>3. 并列句：上下句有逻辑关系，必须加逻辑关系词</h2><table><thead><tr><th align="center">关系</th><th align="center">单词</th><th align="center">短语</th></tr></thead><tbody><tr><td align="center">因</td><td align="center">because</td><td align="center">in that, because of, due to, thanks to</td></tr><tr><td align="center">果</td><td align="center">so, therefore, thus</td><td align="center">as a result, consequently&#x3D;in concequence</td></tr><tr><td align="center">并</td><td align="center">and, likewise, simultaneously</td><td align="center">at the same time &#x3D; in the meanwhile</td></tr><tr><td align="center">转</td><td align="center">but, conversely, alternatively, otherwise</td><td align="center">by contrast, on the contrary, on the other hand</td></tr><tr><td align="center">递</td><td align="center">also, besides, moreover</td><td align="center">in addition</td></tr><tr><td align="center">让</td><td align="center">although</td><td align="center">there is no doube that,in effect&#x2F;fact &#x3D; indeed</td></tr><tr><td align="center">引出新对象</td><td align="center">as for</td><td align="center">关于xx</td></tr><tr><td align="center">总结</td><td align="center">substantially</td><td align="center"></td></tr></tbody></table><p> <em><strong>在过去一千年里，乌镇的水系和生活方式并未经历多少变化,是一座展现古文明的博物馆。</strong></em><br>In the past thousand years, the water system and live style in Wuzhen have not got through many changes. Therefore, it is a museum to show ancient civilization.</p><p><em><strong>这些资金用于改善教学设施、购买书籍，使16万多所中小学收益。资金还用于购置音乐和绘画器材。现在农村和山区的儿童可以与沿海城市的儿童一样上音乐和绘画课。</strong></em><br>These money were used to improve educational facilities(teaching equipment) and purchase books , making 160 thousands primary school and middle schools benefit from them.In addition, the funds were used to purchase music and painting facilities(device). Therefore, children in the rural areas(villages) have music and painting lesson like children in coastal cities.</p><p><em><strong>由于这个传统,许多年轻人婚后继续与父母同住。今天，这个传统正在改变。随着住房条件的改善,越来越多年轻夫妇选择与父母分开住。但他们之间的联系依然很密切，许多老年人仍然帮着照看孙辈。年轻夫妇也抽时间探望父母，特别是在春节和中秋节等重要节日。</strong></em><br>Because of this tradition, many youngs live with parents after their marriage. By contrast, it is changing now. As the improvement of houses, an incresing number of young couples don’t choose to live with their parents.But the connection between them remains strong. Many old people still help them to take care of their grandchildren.At the same time, young couples also visit parents, especially during holidays such as Spring Festival and Mid-Auturn Festival.</p><p><em><strong>《红楼梦》融合了现实主义和浪漫主义，具有很强的艺术感染力。它被普遍认为是中国最伟大的小说，也是世界上最伟大的文学创作之一。</strong></em><br>hlm combines the realism with romantism, having a great influence in art. It is widly <mark>regarded as</mark> the greatest noval in China, at the same time, it is one of the greatest literary creations in the world.</p><p><em><strong>青藏铁路大大缩短了去西藏的旅行时间。更重要的是，它极大地促进了西藏的经济发展，改善了当地居民的生活。</strong></em><br>The Tibet railway has greatly shortened the time to tebet. More importantly, it has greatly promoted the economic development in Tibet, improving the life of local residents.</p><h2 id="4-复合句"><a href="#4-复合句" class="headerlink" title="4. 复合句"></a>4. 复合句</h2><ul><li><p>(1) 主语从句<br>It is … that<br>①It is beyond dispute that …  <font color=red><em>(可以写在任何地方)</em></font><br>②It is my arguement that…<br><em><strong>显而易见关于网络虚假信息这个问题早就应该引起我们的关注了。</strong></em><br>lt is beyond dispute that the issue of false information on the Internet should have aroused our attention. (pay attention to)<br><em><strong>我认为学习的方法和动机远比学习本身更重要</strong></em><br>It is my arguement that the method and motivation of study is are far more important than study itself. </p></li><li><p>(2) 同位语的使用  (同位语是用来解释名词的词汇)</p><ol><li>名词做同位语：只要见到名词，都可以在后面加上一个名词，作为同位语出现<br> Overprotecting kids, a popular issue among the elderly, proves quite serious throughout China.<br> <font color=red><em>a popular issue (among the youngsters)&#x2F;(in the world)</em> </font><br> China’s poverty alleviation, a hot topic especially in counties and villages, has become successful recently.<br> Innovation, a widespread topic in the world, plays a key role in the advance of Chinese economic development.  </li><li>同位语从句：<br> <em><strong>我不同意每个人都需要很强的沟通能力这个观点</strong></em><br> I disagree with the idea that everyone needs strong communication skills.</li></ol><p> <em><strong>温室里的花朵不能经受风雨这个事实表明父母不应该过度保护孩子。</strong></em><br> The fact that flowers in the greenhouse can’t withstand the storms shows that oarents should not overprotect their children.      </p><p><em><strong>我们目前有如此高的失业率这个事实表明，再次接收公司的技能培训是必然的。</strong></em><br>The fact that we have such a high unemployment rate at the moment suggests that receiving skills training from companies again is inevitable</p></li><li><p>(3) 定语从句<br><em><strong>井冈山地处湖南江西两省交界处，因其辉煌的革命历史被誉为“中国革命红色摇篮”。</strong></em><br>Jinggangshan is located at the junction of Hunan and Jiangxi provinces, which is known as the “red cradle of Chinese Revolution”, becaues of it’s glorious revolution history.</p><p><em><strong>青海省得名于全国最大的咸水湖青海湖，青海湖被誉为“中国最美的湖泊”，是最受欢迎的旅游景点之一，也是摄影师和艺术家的天堂。</strong></em><br>Qinghai province is famous for the country’s largest saltwater lake, Qinghai Lake, which is known as “the most beautiful lake in China”, is one of the most popular tourist place and is a haven for photographers and artists. </p><p><em><strong>荷花迎骄阳而不惧，出污泥而不染，象征纯洁、高雅，历来是诗人画家创作的重要题材。</strong></em><br>Lotus flowers face the hot sun without fear and come outof the dirty without stains, which symbolize purity andelegance, and have always been an important subject for poets and painters.</p><p><em><strong>随着中国经济的蓬勃发展，学汉语的人数迅速增加，使汉语成了世界上人们最爱学的语言之一。</strong></em><br>With the great develoment of Chinese economy(With the booming of China’s economy), the number of Chinese learner increases rapidly, which makes Chinese one of the most popular languages in the world. </p></li><li><p>(4) 状语和状语从句<br>什么是状语: 句子中见到以下成分都是状语：<code>adv</code>，<code>时间</code>，<code>地点</code>，<code>原因</code>，<code>目的</code>，<code>条件</code>，<code>让步（althought）</code>，<code>方式（by doing sth ）</code>，<code>结果（so …… that）</code>， <code>伴随</code>，<code>比较</code>。  同时状语的位置很灵活，随便放。<br>状语的成分：副词，介词短语，非谓语动词，从句。<br><em><strong>I love my mother</strong></em><br>I love my mother, becaues she give me live.<br>I love my mother, although she always hit me.<br>I love my mother forever.<br><em><strong>keeping pets can make children patient.</strong></em><br>although they sometimes bring much trouble for their owners.<br>because taking care of those little animals needs kindness.<br>by taking with those little critters.  </p></li><li><p>(5) 三大经典句型  </p><ol><li>强调句（不能强调谓语）<br><code>It is ... that </code>, 去掉后，句子成分不变。</li></ol><p><em><strong>也是在明代，由郑和率领的船队曾到印度洋进行了其次大规模探险航行</strong></em><br>It was also in the Ming dynasty that the fleet led by ZhengHe made seven large-scale exploratory voyages to the Indian Ocean.  </p><ol start="2"><li>虚拟语气（写作）<br>if引导的虚拟语气（与事实相反）——主将从现<br><code>只需将正常句子的时态变成过去式（be动词全写成were），分析原因时好用</code><br><em><strong>如果多数年轻人都没有自信，他们到死将一事无成</strong></em><br>lf most of youngsters failed to be confident, they would achieve nothina until the end of their life<br><em><strong>如果一个人有家庭责任感，他就会以家人为中心，把时间花在陪伴家人上</strong></em><br>lf one had a sense of family responsibility, he would focuson his family and spend time with them.<br><em><strong>如果能找到正确的学习方法，就能在学习中做到事半功倍</strong></em><br>If you found the right way to learn, you would get twice the result with half the effort in learning</li></ol><p>should引导的虚拟语气<br><code>It is necessary that sb should do .</code>  </p><ol start="3"><li>倒装句（把一句话写成一般疑问句）<br> 倒装的具体用法：<br> ① 否定词放句首时用倒装<br> <em><strong>I have never been to other countries except Japan.</strong></em><br> Never have I been to other countries except Japan.<br> <em><strong>She seldom takes a shower in winter</strong></em><br> Seldom does she takes a shower in winter<br> <em><strong>The public can fail to pour attention into the issue of pollution under no circumstances.</strong></em><br> Under no circumstances can the public fail to pour attention into the issue of pollution<br> ②含有so… that…结构的句子将so引导的部分置于句首时用倒装<br> <code>作文有形容词/副词都可以有机会加so that,即可以出现倒装</code><br> <em><strong>He was so excited that he cannot help laughing at midnight。</strong></em><br> So excited was he that he cannot help laughing at midnight<br> <em><strong>He is giving a speech so forcefully that everyone present isconvinced</strong></em><br> So forcefully is he giving a speech that everyone present is convinced<br> ③only + 状语”位于首时用倒装<br> <em><strong>His girlfriend called his name only once.</strong></em><br> Only once did his girlfriend call his name.<br> <em><strong>My dearest mother always lives only in my deep heart.</strong></em><br> Only in my deep heart does my dearest mother always lives.</li></ol></li></ul><h2 id="5-段落的论证方式"><a href="#5-段落的论证方式" class="headerlink" title="5. 段落的论证方式"></a>5. 段落的论证方式</h2><p> (1) 因果论证<br> <em><strong>if我们阅读名著，就会xxxx</strong></em><br> 可以在此基础上继续延伸：如果我们阅读名著，我们就能增加知识，我们知识越多，我们的眼界就越开阔。<br> <em><strong>如果我们阅读名著，就能xxx</strong></em>  </p><p> (2) 分类论证<br> 尤其在描述sth的危害或影响时使用，比如说盗版&#x2F;假冒产品&#x2F;不良广告的危害：对国家，社会&#x2F;集体和个人。<br><em><strong>The importance of mutual understanding and respect in interpersonal relationships.</strong></em><br>In a dormitory, if every menber could understand and respect each other, they might become more creative and effective in their study. In addition, it is such mutual understanding in interpersonal relationships that will result in a warm campus environment. In the end, there would be less conflict thoughout our coountry. How desirable the vision is.   </p><p>(3) 统计和事实<br>On the basis of the proximate data by Cambrige University, the majority of 人 argue that 中心句   </p><p>(4) 举例子  </p><h2 id="6-作文"><a href="#6-作文" class="headerlink" title="6. 作文"></a>6. 作文</h2><h3 id="1-论说文"><a href="#1-论说文" class="headerlink" title="1. 论说文"></a>1. 论说文</h3><p>第一段：引出话题+个人观点<br><code>What is your idea as to …… ? There exist a variety of points concerning it. </code> + <code>From my perspective, </code><br>第二段：分析原因的总起句<br><code>Quite a few factors, as a matter of fact, could account for my opinion.</code><br>第三段：总结<br>As a result, just as coin has two sides, sth is no exception.<br>具体措施（我们&#x2F;政府&#x2F;家长&#x2F;学校&#x2F;）：<br>例1：Students,from their early age, could be educated to cultivate the awareness that methods of learning are more important than learning itself.<br>例2：Authorities could broadcast the importance of community responsibility in public.<br>喊口号：<br>Only by taking these action can people have a more brilliant and glorious future.  </p><h4 id="例文"><a href="#例文" class="headerlink" title="例文"></a>例文</h4><p><em><strong>For this part, you are allowedminutes to write an essaon the importance of motivation and methods in learningYou can cite examples to illustrate your views. You shouldwrite at least 150 words but no more than 200 words</strong></em>   </p><p>&emsp;&emsp;<code>There exists</code>, <code>among</code> teenagers and youngsters, <code>a hot debate on</code> the importance of motivation and methods in learing. <code>From my perspective</code>, it is motivation and methods that prove to be more crucial than the study itself.(引出话题+观点分析)<br>&emsp;&emsp;<code>Quite a few factors, as a matter of fact, could account for my opinion.</code> <code>As the primary element</code>, motivation is an indispensable part of learning. If we desire to complete heavy tasks smoothly, it is motivation that would make us be confronted with troubles without fear. <code>One of Chinese scientists, Yuanlongping,</code> is a good case in point. Before he became the top man known to all, he had failed thousands of times. Without motivation, he might got nothing. <code>Besides, proper methods are alse crucial. </code>because right ways enable you to attain what you want rapidly and effectively. <code>The more efficiently you study, the greater success you will achieve. </code>(两个因果论证，原因分析)<br>&emsp;&emsp;<code>In a word, it is high time that attention could be paid to</code> the motivation and methods of learning. So parents should educate their kids to have a right method and motivation in their study.As a university student, we should explore more effective ways to learn. Only in such ways of thinking can our work be done rapidly and comfortable. (两个结论&#x2F;喊口号)  </p><p><em><strong>For this part, you are allowed 30 minutes to write an essayon the importance of having a sense of community responsibility. You should write at least 150 words but nomore than 200 words</strong></em></p><h3 id="2-谚语警句"><a href="#2-谚语警句" class="headerlink" title="2. 谚语警句"></a>2. 谚语警句</h3><p>第一段：引出主题+解释理解<br>第二段：原因分析+举例<br>第三段：总结+措施</p><p><em><strong>Directions: For this part, you are allowed 30 minutes to writean essay on the saying Wealth of the mind is the only true wealth. You should write at least 150 words but no morethan 200 words.</strong></em><br>&emsp;&emsp;When it comes wealth, ideas may differ among men and wemen in all walks. From my perspective, I approve the arguement that it is wealth of the mind that keeps the only true wealth.<br>&emsp;&emsp;Although numerous cases are available for this argument, the following one about my teacher liu is the most suitable. She wa born in a poor family with three siblings. Furthermore, she, years later, failed to realize her dream to attend an esteemed university even though she studied hard during her senior high school. Under such situations, she has never given herself up, being convinces that “form the gutter, we can still look up at the stars.” And what she disagrees is that poverty is never scaring. What she scare is that your minds are needy. It is through years of endeavors that her dream came true. Still, she keeps my spiritual mentor. So the story vividly tell us that wealth of minds is more essentially valued than funds.<br>&emsp;&emsp;To conclude, it is high time for teenagers and youngsters to persue mental richness because there is no boundary about the wealth of money. Only by thinking like this acan we become more optimistic and lead a harmonious life.</p><h3 id="3-图表作文"><a href="#3-图表作文" class="headerlink" title="3. 图表作文"></a>3. 图表作文</h3><p>图表词汇：chart,table<br>增加：rise, accumulate<br>减少：decline, shrink<br>大幅度：sharply<br>慢慢的：gradually<br>&emsp;&emsp;It is self-evident that in the bar chart, the number if students in higher education, from 1990 to 2019, increased sharply by51.6percent. the meaning behind is quite conspicious: more andmore Chinese teenagers enjoy better education than their predecessors in China.<br>&emsp;&emsp;There are quite a few gounds as follows. with the Reform andOpening up, The economy of China has been developing by leaps andbounds. Meanwhile,Chinese citizen’s life has been also gradually from”subsistence type” to “basic well-being type”, and Social programs have developed vigorously. With the improvement of living standard, an increasing number of Chinese would like to improve themselves. in addition, Parents attach great importance to their children’s education, who is willing to sacrifice everything for their children’s future. in the end, the expression that Knowledge changes destiny takes root in the depth of our minds.So if we want to have a glories future, we have to study hard.<br>&emsp;&emsp;In conclusion, it is knowledge that plays a key role in children’ education. However, parents, from the early age of their children, should inspire them to have right motives and methods. Besides, as universitystudents, We should put what we learn in to practice.Only in this way can knowledge become a beneficial weapon in the future career</p><h2 id="7-翻译"><a href="#7-翻译" class="headerlink" title="7. 翻译"></a>7. 翻译</h2><p>中国历史，文化，经济，社会<br>通过非谓语，从句，并列句子连接。  </p><ol><li>以意群为单位读句子，确认句子的语态和时态  </li><li>确定句子的主干，非主干部分用定语或状语翻译  </li><li>每句话翻译完之后看该句子和下句的逻辑关系，加逻辑关系词<br><em><strong>长江流经多种不同的生态系统，是诸多濒危物种的栖息地，灌溉了中国五分之一的土地。</strong></em><br>The Yangzi River, flowing through different ecological systems,keeps the habitat of plentiful endangered animals, irrigating one fifth of China’s land.<br><em><strong>乌镇是浙江的一座古老水镇，坐落在京杭大运河畔人的地方，这是一处迷人的地方，有许多古桥、中式旅店和餐馆。</strong></em><br>Wuzhen is an ancient water town in Zhejiang Province, locatednear , the Beijing-Hangzhou Grand Canal, which is really acharming place with many ancient bridges, Chinese style hotelsand restaurants there.</li></ol><p><em><strong>在中国，父母总是竭力帮助孩子，甚至为孩子做重要决定，而不管孩子想要什么，因为他们相信这样做是为孩子。结果，孩子的成长和教育往往屈从于父母的意愿。如果父母决定为孩子报名参加一个课外班，以增加其被重点学校录取的机会，他们会坚持自己的决定，即使孩子根本不感兴趣。然而在美国，父母很可能会尊重孩子的意见，并在决策时更注重他们的意见。中国父母十分重视教育或许值得称赞。然而，他们应向美国父母学习在涉及教育时如何平衡父母与子女间的关系。</strong></em><br>In China, parents always try their best to help their children, even making important decision for them and ignoring what they want, because they belive it is beneficial for their children. In the end, the develop way of children will be chosen by their parents. If parents decide to take their children to a Extracurricular classes to add the opportunities of being admitted by excellent senior high school, they will insist their decision although kids don’t interest in it.However, in American, parents always respect their children’s ideas and especially making decision. It is worth to praise that Chinses parents are serious about education, but they should study how to balance the relationship concerning the education with kids from Amarican parents.<br><em><strong>云南是位于中国西南的一个省，平均海拔1500米。云南历史悠久，风景秀丽，气候宜人。云南生态环境优越生物多种多样，被誉为野生动植物的天堂云南还有多种矿藏和充足的水资源，为全省经济的可持续发展提供了有利条件。云南居住着25个少数民族，他们大多有自己的语言习俗和宗教。云南独特的自然景色和丰富的民族文化使其成为中国最受欢迎的旅游目的地之一，每年都吸引着大批国内外游客前往观光旅游</strong></em><br>Yunnan is a province in southwest China with and average altitude of 1500 meters . Yunnan has a long history, beautiful scene and suitable climate. Yunnan has excellent environment and various animals, known as paradise of wild animals and plants. There are also many different mineral resourse and enough water resource in Yunnan, which provide favorable conditions for the sustainable development of economy in province. There are 25 peoples live in Yunnan, most of whom have their own language customs and religions. Because of the unique natural scenery and various peoples cultures, Yunnan become one of the most popular tourist attration in China, attracting a lots of travellers form China and other countries.</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>In an era of imformation explorsion, it is vitally important to develop the ability to think critically and make rational choices.<br>From my perspecttive, nowadays, we have to recept too much imformation and we will be decived if we couldn’t identify the false imformation.  </p>]]></content>
      
      
      <categories>
          
          <category> 四六级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表的基本操作</title>
      <link href="/2023/10/20/data_structure/exersics/"/>
      <url>/2023/10/20/data_structure/exersics/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h1><ol><li><p>从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Bool <span class="title function_">DelMin</span> <span class="params">(SqList &amp;L , ElemType &amp;min)</span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    min = L.Data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; L.length;i++)</span><br><span class="line">        <span class="keyword">if</span>(min &lt; L.Data[i])&#123;</span><br><span class="line">            min == L.Data[i];</span><br><span class="line">            num = i;</span><br><span class="line">        &#125;</span><br><span class="line">    L.Data[num] = L.Data[L.length<span class="number">-1</span>];</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>没汁一个高效算法，将順序表L的所有元素逆置，要求算法的空间复杂度为 O（1）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> head,last;</span><br><span class="line">    head = <span class="number">0</span>,last = L.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head == last ||head<span class="number">-1</span> == last)&#123;</span><br><span class="line">        ElemType e;</span><br><span class="line">        e = L.Data[head];</span><br><span class="line">        L.Data[head] = L.Data[last];</span><br><span class="line">        L.Data[last] = e;</span><br><span class="line">        head++;last--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准答案</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">(Sqlist &amp;L)</span>&#123;</span><br><span class="line">    ElemType temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        temp = L.data[i];</span><br><span class="line">        L.data[i] = L.data[L.length-i<span class="number">-1</span>];</span><br><span class="line">        L.data[L.length-i<span class="number">-1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对长度为n的顺序表L，编写一个时问复杂度为0（n、空间复杂度为Q(1)的算法，该算法删除线性表中所有值为x的数据元素。</p></li></ol><pre><code class="c">coid del_x(Sqlist &amp;L,ElemType x)&#123;    int k = 0,i;    for (i=0;i&lt;L.length;i++)        if(L.data[i]!=x)&#123;            L.data[k] = L.data[i];            k++        &#125;    L.length = k;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研，算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java企业设计实验遇到的问题</title>
      <link href="/2023/09/27/shiyan/java_problem/"/>
      <url>/2023/09/27/shiyan/java_problem/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表&amp;数组算法技巧汇总</title>
      <link href="/2023/08/30/suanfa/arraylist-linkedlist3/"/>
      <url>/2023/08/30/suanfa/arraylist-linkedlist3/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>参考自labuladong的算法小抄<br>因为滑动窗口很多时候都是在处理字符串相关的问题，而 Java 处理字符串不方便，所以本文代码为 C++ 实现。不会用到什么特定的编程语言技巧</p><h2 id="大体框架"><a href="#大体框架" class="headerlink" title="大体框架"></a>大体框架</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用合适的数据结构记录窗口中的数据</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        window.<span class="built_in">add</span>(c)</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="comment">// 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment">// 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            window.<span class="built_in">remove</span>(d)</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：<a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a><br><strong>滑动窗口思路</strong></p><ol><li><p>我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引左闭右开区间<code> [left, right)</code> 称为一个「窗口」。  </p></li><li><p>我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code>T</code> 中的所有字符）。  </p></li><li><p>此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 <code>T</code> 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。     </p></li><li><p>重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code>的尽头。</p></li></ol><p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」</strong>，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p><h1 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a>差分数组</h1><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h1 id="前缀和数组"><a href="#前缀和数组" class="headerlink" title="前缀和数组"></a>前缀和数组</h1><div class="note danger flat"><p>由于二分查找和前缀和都以数组为例，因此都更新在<a href="./arraylist1.md">数组算法</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的常用算法</title>
      <link href="/2023/08/25/suanfa/stack/"/>
      <url>/2023/08/25/suanfa/stack/</url>
      
        <content type="html"><![CDATA[<h1 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h1><p><a href="https://leetcode.cn/problems/reorder-list/">https://leetcode.cn/problems/reorder-list/</a><br>大晚上的有的昏昏的也不想做，没什么思路，明天再写。<br>看不懂，烦躁<br>算法好难学啊</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2023/08/19/suanfa/stack_queue/"/>
      <url>/2023/08/19/suanfa/stack_queue/</url>
      
        <content type="html"><![CDATA[<h1 id="链表实现队列和栈"><a href="#链表实现队列和栈" class="headerlink" title="链表实现队列和栈"></a>链表实现队列和栈</h1><p>先看栈，我们使用链表的头部作为栈顶，链表的尾部作为栈底。实现比较简单，直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    list.addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.getFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表实现队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node head, tail;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="comment">// 当tail为空时，也就意味着head也为空</span></span><br><span class="line">    <span class="keyword">if</span>(tail == <span class="literal">null</span>)&#123;</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(e);</span><br><span class="line">        head = tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tail.next = <span class="keyword">new</span> <span class="title class_">Node</span>(e);</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">dequeue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot dequeue from an empty queue.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">retNode</span> <span class="operator">=</span> head;</span><br><span class="line">    head = head.next;</span><br><span class="line">    retNode.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特殊情况：链表中只有一个元素，若删除，则为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>)&#123;</span><br><span class="line">        tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> retNode.e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getFront</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot dequeue from an empty queue.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双端队列的实现"><a href="#双端队列的实现" class="headerlink" title="双端队列的实现"></a>双端队列的实现</h1><p>与队列最大的不同就是：前后都可以添加和删除元素。所以会出现通过数组指针更快地添加和删除元素的操作。<br>但是要注意特殊情况：<code>情况一：first----last</code>, <code>情况二：---last  first---</code>  </p><div class="note info flat"><p>什么时候手敲过一遍啊</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayDeque</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">INIT_CAP</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data 的索引区间 [first, last) 存储着添加的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> first, last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyArrayDeque</span><span class="params">(<span class="type">int</span> initCap)</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        data = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[initCap];</span><br><span class="line">        <span class="comment">// 都初始化为 0，区间 [0,0) 是空集</span></span><br><span class="line">        first = last = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyArrayDeque</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不传参数，默认大小为 INIT_CAP</span></span><br><span class="line">        <span class="built_in">this</span>(INIT_CAP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 增 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从头部插入元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == data.length) &#123;</span><br><span class="line">            resize(size * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况一：first----last</span></span><br><span class="line">        <span class="comment">// 情况二：---last  first---</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左移 first，所以 first == 0 是一种特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="number">0</span>) &#123;</span><br><span class="line">            first = data.length - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            first--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        data[first] = e;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从尾部插入元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == data.length) &#123;</span><br><span class="line">            resize(size * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入元素</span></span><br><span class="line">        data[last] = e;</span><br><span class="line">        last++;</span><br><span class="line">        <span class="keyword">if</span> (last == data.length) &#123;</span><br><span class="line">            last = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 删 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从头部删除元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size == data.length / <span class="number">4</span>) &#123;</span><br><span class="line">            resize(data.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> data[first];</span><br><span class="line">        data[first] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        first++;</span><br><span class="line">        <span class="keyword">if</span> (first == data.length) &#123;</span><br><span class="line">            first = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从尾部删除元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size == data.length / <span class="number">4</span>) &#123;</span><br><span class="line">            resize(data.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况一：first----last</span></span><br><span class="line">        <span class="comment">// 情况二：---last  first---</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左移 last，当 last == 0 的时候是特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="number">0</span>) &#123;</span><br><span class="line">            last = data.length - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> data[last];</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        data[last] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 查 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从头部获取元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[first];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从尾部获取元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (last == <span class="number">0</span>) <span class="keyword">return</span> data[data.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> data[last - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 工具函数 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCap)</span> &#123;</span><br><span class="line">        E[] temp = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newCap];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//   first-----last</span></span><br><span class="line">        <span class="comment">// ---last    first---</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            temp[i] = data[(first + i) % data.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">        last = size;</span><br><span class="line">        data = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RingBuffer的参考实现"><a href="#RingBuffer的参考实现" class="headerlink" title="RingBuffer的参考实现"></a>RingBuffer的参考实现</h1><p>有点不太记得住，因为感觉目前暂时不太需要用得到，然后还有一个重要的位运算技巧，但是要先更新写在这里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RingBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] buffer;</span><br><span class="line">    <span class="comment">// mask 用于防止索引越界</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mask;</span><br><span class="line">    <span class="comment">// 读写指针的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> r, w;</span><br><span class="line">    <span class="comment">// 记录可以读取的字节个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 默认初始化的 buffer 大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INIT_CAP</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RingBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(INIT_CAP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RingBuffer</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="comment">// 将输入的 cap 变成 2 的指数</span></span><br><span class="line">        cap = ceilToPowerOfTwo(cap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果保证 capacity 是 2 的指数，</span></span><br><span class="line">        <span class="comment">// (i + n) % capacity 等价于 (i + n) &amp; mask</span></span><br><span class="line">        mask = cap - <span class="number">1</span>;</span><br><span class="line">        buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[cap];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读/写指针初始化在索引 0</span></span><br><span class="line">        r = w = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 还没有写入任何数据，可读取字节数为 0</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 RingBuffer 中读取元素到 out 中，返回读取的字节数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] out)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (out == <span class="literal">null</span> || out.length == <span class="number">0</span> || isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取的字节数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Math.min(size, out.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况1： r----w</span></span><br><span class="line">        <span class="keyword">if</span> (w &gt; r) &#123;</span><br><span class="line">            <span class="comment">// r----w 读取后变成 **r--w</span></span><br><span class="line">            <span class="comment">// copy data[r..r+n] to out[0..]</span></span><br><span class="line">            System.arraycopy(buffer, r, out, <span class="number">0</span>, n);</span><br><span class="line">            <span class="comment">// 向前移动读指针</span></span><br><span class="line">            r += n;</span><br><span class="line">            <span class="comment">// 可读取的字节数减少了 n</span></span><br><span class="line">            size -= n;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况2：--w  r---</span></span><br><span class="line">        <span class="keyword">if</span> (r + n &lt;= buffer.length) &#123;</span><br><span class="line">            <span class="comment">// 情况2.1：--w  r--- 读取后变成 --w  **r-</span></span><br><span class="line">            <span class="comment">// copy data[r..r+n] to out[0..]</span></span><br><span class="line">            System.arraycopy(buffer, r, out, <span class="number">0</span>, n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 情况2.2：----w  r-- 读取后变成  *r--w  ***</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> buffer.length - r;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> n - n1;</span><br><span class="line">            <span class="comment">// copy data[r..] to out[0..n1]</span></span><br><span class="line">            System.arraycopy(buffer, r, out, <span class="number">0</span>, n1);</span><br><span class="line">            <span class="comment">// copy data[0..n2] to out[n1..]</span></span><br><span class="line">            System.arraycopy(buffer, <span class="number">0</span>, out, n1, n2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前移动读指针</span></span><br><span class="line">        r = (r + n) &amp; mask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可读取的字节数减少了 n</span></span><br><span class="line">        size -= n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 in 中的数据写入 RingBuffer，返回写入字节的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] in)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in == <span class="literal">null</span> || in.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.length;</span><br><span class="line">        <span class="comment">// 还未使用的字节数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">free</span> <span class="operator">=</span> buffer.length - size;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; free) &#123;</span><br><span class="line">            <span class="comment">// 确保 buffer 容量足够</span></span><br><span class="line">            ensureCapacity(length() + n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况1：r---w，还要细分两种情况</span></span><br><span class="line">        <span class="keyword">if</span> (w &gt;= r) &#123;</span><br><span class="line">            <span class="comment">// 情况1.1：r---w 写入后变成 r---**w</span></span><br><span class="line">            <span class="keyword">if</span> (buffer.length - w &gt;= n) &#123;</span><br><span class="line">                <span class="comment">// copy in[0..] to data[w..w+n]</span></span><br><span class="line">                System.arraycopy(in, <span class="number">0</span>, buffer, w, n);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 情况1.2：r---w 写入后变成 **w  r---*</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> buffer.length - w;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> n - n1;</span><br><span class="line">                <span class="comment">// copy in[0..n1] to data[w..]</span></span><br><span class="line">                System.arraycopy(in, <span class="number">0</span>, buffer, w, n1);</span><br><span class="line">                <span class="comment">// copy in[n1..] to data[0..n2]</span></span><br><span class="line">                System.arraycopy(in, n1, buffer, <span class="number">0</span>, n2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 情况二：--w   r--</span></span><br><span class="line">            <span class="comment">// buffer 容量肯定足够，所以直接 copy 就行了</span></span><br><span class="line">            System.arraycopy(in, <span class="number">0</span>, buffer, w, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向前移动 w 指针</span></span><br><span class="line">        w = (w + n) &amp; mask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可读取的字节数增加了 n</span></span><br><span class="line">        size += n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回可读的字节数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有可读的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> newCap)</span> &#123;</span><br><span class="line">        newCap = ceilToPowerOfTwo(newCap);</span><br><span class="line">        <span class="comment">// 将 data 中的数据读入 temp 中</span></span><br><span class="line">        <span class="type">byte</span>[] temp = <span class="keyword">new</span> <span class="title class_">byte</span>[newCap];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> read(temp);</span><br><span class="line">        <span class="comment">// 更新其他字段的值</span></span><br><span class="line">        <span class="built_in">this</span>.buffer = temp;</span><br><span class="line">        <span class="built_in">this</span>.r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.w = n;</span><br><span class="line">        <span class="built_in">this</span>.mask = newCap - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输入的 n 转化为 2 的指数，比如输入 12，返回 16</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ceilToPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 肯定不能小于 0</span></span><br><span class="line">            n = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>)) &#123;</span><br><span class="line">            <span class="comment">// int 型最大值为 2^31 - 1</span></span><br><span class="line">            <span class="comment">// 所以无法向上取整到 2^31</span></span><br><span class="line">            n = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        int res = 1;</span></span><br><span class="line"><span class="comment">//        while (res &lt; n) &#123;</span></span><br><span class="line"><span class="comment">//            res = res * 2;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return res;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 位运算技巧，参考如下链接：</span></span><br><span class="line">        <span class="comment">// http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2</span></span><br><span class="line">        n--;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        n++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RingBuffer</span> <span class="variable">rb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RingBuffer</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abcdefghijklmn&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nwrite</span> <span class="operator">=</span> rb.write(s.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;write &quot;</span> + nwrite + <span class="string">&quot; bytes &quot;</span> + s);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] out = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">nread</span> <span class="operator">=</span> rb.read(out);</span><br><span class="line">        System.out.println(<span class="string">&quot;read &quot;</span> + nread + <span class="string">&quot; bytes &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(out));</span><br><span class="line"></span><br><span class="line">        nread = rb.read(out);</span><br><span class="line">        System.out.println(<span class="string">&quot;read &quot;</span> + nread + <span class="string">&quot; bytes &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(out));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//write 14 bytes abcdefghijklmn</span></span><br><span class="line">        <span class="comment">//read 9 bytes abcdefghi</span></span><br><span class="line">        <span class="comment">//read 5 bytes jklmnfghi</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实际中栈的常用方法"><a href="#实际中栈的常用方法" class="headerlink" title="实际中栈的常用方法"></a>实际中栈的常用方法</h1><ul><li>实例化一个对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br></pre></td></tr></table></figure></li><li>判断是否为空 <code>stk.isEmpty()</code>;</li><li>入栈<code>stk.push()</code>;</li><li>出栈<code>stk.pop()</code>;</li><li>显示栈顶头元素，但不移除<code>stk.peek()</code>;</li></ul><h1 id="队列的常用方法"><a href="#队列的常用方法" class="headerlink" title="队列的常用方法"></a>队列的常用方法</h1><p>在java中，<code>LinkedList</code>类实现了<code>Queue接口</code>，因此我们可以把<code>LinkedList</code>当成<code>Queue</code>来用</p><ul><li>实例化一个对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br></pre></td></tr></table></figure></li><li>判断是否为空 <code>q.isEmpty()</code>;</li><li>添加元素<code>q.offer()</code>;</li><li>删除元素<code>q.poll()</code>;</li><li>显示队列头元素但不移除<code>q.peek()</code>;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网 1</title>
      <link href="/2023/08/16/computer%20network/chapter1/"/>
      <url>/2023/08/16/computer%20network/chapter1/</url>
      
        <content type="html"><![CDATA[<p>只学算法太让人头大了，就想着学一个偏理论一点的，大概两天前开始，我的计算机网络跟着湖科大的视频学。<br>看了点视频，不知道是按着：数据结构-&gt;计组-&gt;OS-&gt;计网这个顺序好，还是自己先过一遍好，但是因为目前是对计网比较感兴趣，，又在学java的算法，不好转成c去学数据结构，所以就还是决定先开比较理论的计网，因为这门科目枯燥，记忆点多，分值低，很多人都会放在最后复习，反正也是纠结了好一会啦。</p><p>2023.10.10<br>粗略学完了一遍啦，但是很多都忘了，而且没怎么做题</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组算法</title>
      <link href="/2023/08/12/suanfa/arraylist1/"/>
      <url>/2023/08/12/suanfa/arraylist1/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针和数组"><a href="#双指针和数组" class="headerlink" title="双指针和数组"></a>双指针和数组</h1><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><h3 id="1-删除有序数组的重复项"><a href="#1-删除有序数组的重复项" class="headerlink" title="1.删除有序数组的重复项"></a>1.删除有序数组的重复项</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">https://leetcode.cn/problems/remove-duplicates-from-sorted-array/</a><br>题目让你原地删除，不允许 new 新数组，只能在原数组上操作，然后返回一个长度，由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难。但如果毎找到一个重复元素就立即原地删除它，由于数组中删除元素涉及数据搬移，整个时间复杂度是会达到<code> O(N^2)</code>，高效解决这道题就要用到快慢指针技巧：我们让慢指针 <code>slow</code> 走在后面，快指针<code> fast</code> 走在前面探路，找到一个不重复的元素就赋值给 <code>slow</code> 并让 <code>slow</code>前进一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[slow]) &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            <span class="comment">// 维护 nums[0..slow] 无重复</span></span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组长度为索引 + 1</span></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://labuladong.github.io/algo/images/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/1.gif" alt="删除重复数组"></p><h3 id="2-移除元素"><a href="#2-移除元素" class="headerlink" title="2.移除元素"></a>2.移除元素</h3><p>此处与上一题非常相似，但是细节上的修改很重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里和有序数组去重的解法有一个细节差异，我们这里是先给 <code>nums[slow]</code> 赋值然后再给 <code>slow++</code>，这样可以保证 <code>nums[0..slow-1]</code> 是不包含值为 <code>val</code> 的元素的，最后的结果数组长度就是 <code>slow</code>。</p><h3 id="3-删除排序链表中的重复元素"><a href="#3-删除排序链表中的重复元素" class="headerlink" title="3.删除排序链表中的重复元素"></a>3.删除排序链表中的重复元素</h3><p>此处与<code>1.删除有序数组的重复项</code>一模一样，只是将数组改为了链表，对应使用链表操作即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.val != slow.val) &#123;</span><br><span class="line">            <span class="comment">// nums[slow] = nums[fast];</span></span><br><span class="line">            slow.next = fast;</span><br><span class="line">            <span class="comment">// slow++;</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fast++</span></span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断开与后面重复元素的连接</span></span><br><span class="line">    slow.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://labuladong.github.io/algo/images/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/2.gif" alt="删除重复链表"></p><h3 id="移动0"><a href="#移动0" class="headerlink" title="移动0"></a>移动0</h3><p><a href="https://leetcode.cn/problems/move-zeroes/">https://leetcode.cn/problems/move-zeroes/</a><br>依旧是可以用上文的思路解决，这里也还没做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### 数组中另一大类快慢指针的题目就是「滑动窗口算法」</span><br><span class="line">这里还没学，先跳过</span><br><span class="line">```java</span><br></pre></td></tr></table></figure><h2 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h2><p>在此之前先学一个很重要的查找算法</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找大致分为三种：1.找一个数（基本的二分搜索） 2. 找右边界 3. 找左边界</p><h4 id="基本的二分搜索"><a href="#基本的二分搜索" class="headerlink" title="基本的二分搜索"></a>基本的二分搜索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br><code>1、为什么 while 循环的条件中是 &lt;=，而不是 &lt;？</code><br>因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>，而此时的<code>right</code>是可以取到实际值的，所以可以相等 我们这个算法中使用的是 <code>[left, right]</code> 两端都闭的区间。这个区间其实就是每次进行搜索的区间。  </p><p>这样写的同时会对终止条件产生影响，若是找到目标时，停止搜索，此时会按照正常的程序进行。而当没有找到目标时，<code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。  </p><p>若是执意要写成<code>while(left &lt; right)</code>,则会造成区间不为空的情况,以上文为例子,带入数字可得到<code>[2,2]</code>,此时索引2被漏掉了,但是while循环语句结束,返回-1,则造成了bug,解决方法也很简单,打一个补丁即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:<br><code>1、为什么 while 中是 &lt; 而不是 &lt;=?</code><br>此处的<code>right = nums.length</code>,与上文不同,已经取到了数组最后一个数的后一位,此数不存在,所以只能为开区间,即<code>[left, right)</code>.此时,<code>while(left &lt; right)</code> 终止的条件是 <code>left == right</code>，此时搜索区间 <code>[left, left)</code> 为空，所以可以正确终止。  </p><p><code>2. 为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？</code><br>与上一问题打补丁的方法类似,在返回的时候额外判断一下<code> nums[left]</code> 是否等于 <code>target</code> 就行了，如果不等于，就说明 <code>target</code> 不存在。需要注意的是，访问数组索引之前要保证索引不越界：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果索引越界，说明数组中无目标元素，返回 -1</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; <span class="number">0</span> || left &gt;= nums.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断一下 nums[left] 是不是 target</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><code>3. 能不能想办法把 right 变成 nums.length - 1，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了。</code><br>当然可以,因为我们是通过[搜索区间]这一概念解决问题的,若使得<code>right = nums.length - 1</code>,则while 的终止条件应该是 <code>left == right + 1</code>，也就是其中应该用 <code>&lt;=</code>.<br>此时的代码为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 target 是否存在于 nums 中</span></span><br><span class="line">    <span class="comment">// 如果越界，target 肯定不存在，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span> || left &gt;= nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断一下 nums[left] 是不是 target</span></span><br><span class="line">    <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="寻找右侧边界的二分查找"><a href="#寻找右侧边界的二分查找" class="headerlink" title="寻找右侧边界的二分查找"></a>寻找右侧边界的二分查找</h4><p>类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:<br><code>1. 为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。</code><br>首先，while 循环的终止条件是 left &#x3D;&#x3D; right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。<br>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在锁定右边界时的这个条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 增大 left，锁定右侧边界</span></span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这样想: mid = left - 1</span></span><br></pre></td></tr></table></figure><p>在循环结束前,程序依旧执行了一次<code>left = mid + 1;</code>,使得最后的<code>left</code>会在<code>target</code>的右侧,例如下图所示<br><img src="https://labuladong.github.io/algo/images/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/3.jpg" alt="img"><br>所以当while循环结束时,<code>nums[left]</code> 一定不等于 <code>target</code> 了，而 <code>nums[left-1]</code> 可能是 <code>target</code>(除非数组中不存在target)<br>若是不存在,则也是打个补丁返回-1即可,非常简单.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断 target 是否存在于 nums 中</span></span><br><span class="line"><span class="comment">// left - 1 索引越界的话 target 肯定不存在</span></span><br><span class="line"><span class="keyword">if</span> (left - <span class="number">1</span> &lt; <span class="number">0</span> || left - <span class="number">1</span> &gt;= nums.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断一下 nums[left - 1] 是不是 target</span></span><br><span class="line"><span class="keyword">return</span> nums[left - <span class="number">1</span>] == target ? (left - <span class="number">1</span>) : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><code>2. 两端都闭的写法</code>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 这里改成收缩左侧边界即可</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后改成返回 left - 1</span></span><br><span class="line">    <span class="keyword">if</span> (left - <span class="number">1</span> &lt; <span class="number">0</span> || left - <span class="number">1</span> &gt;= nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left - <span class="number">1</span>] == target ? (left - <span class="number">1</span>) : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="统一记忆"><a href="#统一记忆" class="headerlink" title="统一记忆"></a>统一记忆</h4><p>对于寻找左右边界的二分搜索，比较常见的手法是使用左闭右开的「搜索区间」，<strong>我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定左侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 target 是否存在于 nums 中</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span> || left &gt;= nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断一下 nums[left] 是不是 target</span></span><br><span class="line">    <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 target 是否存在于 nums 中</span></span><br><span class="line">    <span class="comment">// if (left - 1 &lt; 0 || left - 1 &gt;= nums.length) &#123;</span></span><br><span class="line">    <span class="comment">//     return -1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于 while 的结束条件是 right == left - 1，且现在在求右边界</span></span><br><span class="line">    <span class="comment">// 所以用 right 替代 left - 1 更好记</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || right &gt;= nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[right] == target ? right : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="comment">// 题目要求的索引是从 1 开始的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            left++; <span class="comment">// 让 sum 大一点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            right--; <span class="comment">// 让 sum 小一点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转数组"><a href="#反转数组" class="headerlink" title="反转数组"></a>反转数组</h3><p>这里和上一题都很简单,就是要注意java的基本语法吧,比如<code>char</code>的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 交换 s[left] 和 s[right]</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长子回文串"><a href="#最长子回文串" class="headerlink" title="最长子回文串"></a>最长子回文串</h3><p>还没做,看了下因为基础语法的问题不太想做</p><hr><h1 id="8-16更新"><a href="#8-16更新" class="headerlink" title="8.16更新"></a>8.16更新</h1><p>没什么进展，前面的忘了好多，回去做了一些前面的题目。看了基础的<code>前缀和数组</code>，先挖个坑</p><h2 id="前缀和数组"><a href="#前缀和数组" class="headerlink" title="前缀和数组"></a>前缀和数组</h2><div class="note flat"><p>二维数组是真难理解啊，看了我两小时才看懂….</p></div><h2 id="一维数组前缀和："><a href="#一维数组前缀和：" class="headerlink" title="一维数组前缀和："></a>一维数组前缀和：</h2><p><a href="https://leetcode.cn/problems/range-sum-query-immutable/">https://leetcode.cn/problems/range-sum-query-immutable/</a><br>题目将会给你一个区间与数组，要求你计算出数组区间内的数字和。<br>例如：计算数组[1,2,3,4,5]在下标[1，3]之间的数字和  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="comment">// 前缀和数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] preSum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输入一个数组，构造前缀和 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// preSum[0] = 0，便于计算累加和</span></span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preSum.length; i++) &#123;</span><br><span class="line">            preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 查询闭区间 [left, right] 的累加和 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> preSum[right + <span class="number">1</span>] - preSum[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其核心为，我们通过新建一个数组，存储题目数组的累加和，如图所示：<br><img src="https://labuladong.github.io/algo/images/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/1.jpeg" alt="img"><br>看这个 <code>preSum</code> 数组，如果我想求索引区间 <code>[1, 4]</code> 内的所有元素之和，就可以通过<code> preSum[5] - preSum[1]</code> 得出。<br>这样，<code>sumRange</code> 函数仅仅需要做一次减法运算，避免了每次进行 for 循环调用，最坏时间复杂度为常数 <code>O(1)</code>。</p><h2 id="二维数组前缀和"><a href="#二维数组前缀和" class="headerlink" title="二维数组前缀和"></a>二维数组前缀和</h2><p><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">https://leetcode.cn/problems/range-sum-query-2d-immutable/</a>  </p><p>题目给出矩阵左上角与右下角，需要你计算整个范围内的和，通常，可以用一个嵌套 for 循环去遍历这个矩阵，但这样的话 <code>sumRegion</code> 函数的时间复杂度就高了.<br>而前缀和的思路如下：<br><img src="https://labuladong.github.io/algo/images/%E5%89%8D%E7%BC%80%E5%92%8C/5.jpeg" alt="img"><br>而这四个大矩阵有一个共同的特点，就是左上角都是 (0, 0) 原点。</p><p>那么做这道题更好的思路和一维数组中的前缀和是非常类似的，我们可以维护一个二维 preSum 数组，专门记录以原点为顶点的矩阵的元素之和，就可以用几次加减运算算出任何一个子矩阵的元素和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个二维前缀和数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] presum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">//matrix.length 表示矩阵的行数</span></span><br><span class="line">        <span class="comment">//matrix[0].length 表示矩阵的列数。</span></span><br><span class="line">        <span class="comment">// 这里假设矩阵的每一行都具有相同的列数，所以可以通过访问第一行（matrix[0]）来获取列数。</span></span><br><span class="line">        <span class="comment">// 然后使用 length 属性获取第一行的长度，即为矩阵的列数。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//这里我还不懂为什么return后面没有东西</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        presum = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                presum[i][j] = presum[i - <span class="number">1</span>][j] + presum[i][j - <span class="number">1</span>] - presum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> presum[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - presum[row1][col2 + <span class="number">1</span>] - presum[row2 + <span class="number">1</span>][col1] + presum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我当时为了理解画的鸟图，自己都没有很懂，希望以后看到能自觉看懂，看不懂就算了。<br><img src="https://pic.imgdb.cn/item/64dc8e0d661c6c8e54075479.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表算法与双指针</title>
      <link href="/2023/08/05/suanfa/arraylist-linkedlist2/"/>
      <url>/2023/08/05/suanfa/arraylist-linkedlist2/</url>
      
        <content type="html"><![CDATA[<p>本文参考自：<a href="https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/shuang-zhi-0f7cc/">https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/shuang-zhi-0f7cc/</a></p><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p>比较简单，主要理解建表语法<br><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> list1, p2 = list2;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="literal">null</span>&amp;&amp;p2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.val&lt;p2.val)&#123;</span><br><span class="line">                p.next = p1;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = p1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单链表的分解"><a href="#单链表的分解" class="headerlink" title="单链表的分解"></a>单链表的分解</h1><p><a href="https://leetcode.cn/problems/partition-list/description/">https://leetcode.cn/problems/partition-list/description/</a><br>注意建表语法，两个虚拟节点的使用，原链表的销毁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">bigdummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">smalldummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> bigdummy;<span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> smalldummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val&gt;=x)&#123;</span><br><span class="line">                p1.next = p;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p2.next = p;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//置空原链表</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> temp = p.next;</span><br><span class="line">            p.next = <span class="literal">null</span>;</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        p2.next = bigdummy.next;</span><br><span class="line">        <span class="keyword">return</span> smalldummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a>合并k个有序链表</h1><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a><br>由于这题需要用到优先级队列，所以先看二叉堆的内容。</p><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><ul><li>二叉堆有两个主要操作，用以维护二叉堆的性质，分别是：<code>sink(下沉)</code>和<code>swim(上浮)</code></li><li>有两个主要应用：①排序方法：<code>堆排序</code> ②数据结构：<code>优先级队列</code></li><li>二叉堆是存储在<code>数组</code>里的<code>完全二叉树</code>，我们把数组索引作为指针 (一般的链表二叉树，我们操作节点的指针)</li><li>二叉堆还分为最大堆和最小堆。最大堆的性质是：每个节点都大于等于它的两个子节点。类似的，最小堆的性质是：每个节点都小于等于它的子节点。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父节点的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左孩子的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右孩子的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://labuladong.github.io/algo/images/heap/1.png" alt="二叉堆"></li></ul><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><ul><li>通过优先级队列，可以在<code>插入或者删除元素的时候，元素自动排序</code>，底层原理便是二叉堆的操作。</li><li>数据结构的功能无非增删查改，优先级队列有两个主要 API，分别是<code>insert</code>插入一个元素和 <code>delMax</code> 删除最大元素（如果底层用最小堆，那么就是 <code>delMin</code>）。<br>代码框架如下：<div class="note success flat"><p>这里用到 Java 的泛型，Key 可以是任何一种可比较大小的数据类型，比如 Integer 等类型</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span></span><br><span class="line">    &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="comment">// 当前 Priority Queue 中的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPQ</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引 0 不用，所以多分配一个空间</span></span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[cap + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入元素 e */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key e)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除并返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 上浮第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> x)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下沉第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> x)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 交换数组的两个元素 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">temp</span> <span class="operator">=</span> pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pq[i] 是否比 pq[j] 小？ */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 还有 left, right, parent 三个方法 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="实现-swim-和-sink"><a href="#实现-swim-和-sink" class="headerlink" title="实现 swim 和 sink"></a>实现 swim 和 sink</h2><ul><li><p><code>swim</code> 和 <code>sink </code>是为了维护堆结构而存在。</p></li><li><p><code>swim</code> 和 <code>sink</code> 是互逆的，上浮的操作也可以通过下沉完成，之所以要写两个方法，是因为我们最终的操作只会在堆顶和堆底进行。</p></li><li><p>swin代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果浮到堆顶，就不能再上浮了</span></span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">1</span> &amp;&amp; less(parent(x), x)) &#123;</span><br><span class="line">            <span class="comment">// 如果第 x 个元素比上层大</span></span><br><span class="line">            <span class="comment">// 将 x 换上去</span></span><br><span class="line">            swap(parent(x), x);</span><br><span class="line">            x = parent(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://labuladong.github.io/algo/images/heap/swim.gif" alt="swim"></p></li><li><p>sink代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果沉到堆底，就沉不下去了</span></span><br><span class="line">        <span class="keyword">while</span> (left(x) &lt;= size) &#123;</span><br><span class="line">            <span class="comment">// 先假设左边节点较大</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> left(x);</span><br><span class="line">            <span class="comment">// 如果右边节点存在，比一下大小</span></span><br><span class="line">            <span class="keyword">if</span> (right(x) &lt;= size &amp;&amp; less(max, right(x)))</span><br><span class="line">                max = right(x);</span><br><span class="line">            <span class="comment">// 结点 x 比俩孩子都大，就不必下沉了</span></span><br><span class="line">            <span class="keyword">if</span> (less(max, x)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 否则，不符合最大堆的结构，下沉 x 结点</span></span><br><span class="line">            swap(x, max);`</span><br><span class="line">            x = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="hhttps://labuladong.github.io/algo/images/heap/sink.gif" alt="sink"></p></li></ul><h1 id="实现-delMax-和-insert"><a href="#实现-delMax-和-insert" class="headerlink" title="实现 delMax 和 insert"></a>实现 delMax 和 insert</h1><ul><li>这两个方法就是建立在<code>swim</code>和<code>sink</code>上的。</li><li><code>insert</code> 方法先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key e)</span> &#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">// 先把新元素加到最后</span></span><br><span class="line">        pq[size] = e;</span><br><span class="line">        <span class="comment">// 然后让它上浮到正确的位置</span></span><br><span class="line">        swim(size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>*<code>delMax</code>方法先把堆顶元素 <code>A</code> 和堆底最后的元素 <code>B</code> 对调，然后删除 <code>A</code>，最后让 <code>B</code> 下沉到正确位置。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 为了节约篇幅，省略上文给出的代码部分...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 最大堆的堆顶就是最大元素</span></span><br><span class="line">        <span class="type">Key</span> <span class="variable">max</span> <span class="operator">=</span> pq[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 把这个最大元素换到最后，删除之</span></span><br><span class="line">        swap(<span class="number">1</span>, size);</span><br><span class="line">        pq[size] = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// 让 pq[1] 下沉到正确位置</span></span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>至此，一个优先级队列就实现了，插入和删除元素的时间复杂度为<code> O(logK)</code>，<code>K</code> 为当前二叉堆（优先级队列）中的<code>元素总数</code>。因为我们时间复杂度主要花费在 <code>sink</code> 或者 <code>swim</code>上，而不管上浮还是下沉，最多也就树（堆）的高度，也就是 <code>log</code> 级别。</li></ul><div class="note info flat"><p>回归正题，实现合并k个有序链表。 </p></div><p>看懂了但是写不出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">        lists.length, (a, b)-&gt;(a.val - b.val));</span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>)</span><br><span class="line">            pq.add(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        p.next = node;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pq.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>已经好久没学了，中途还感冒了，又情绪不稳定，摸了几天的鱼。<br>写了好几天连2.1的一半都没做完。。<br>算了，万事开头难，可恶。  </p><h1 id="倒数第k个节点"><a href="#倒数第k个节点" class="headerlink" title="倒数第k个节点"></a>倒数第k个节点</h1><h2 id="单链表的倒数第k个节点"><a href="#单链表的倒数第k个节点" class="headerlink" title="单链表的倒数第k个节点"></a>单链表的倒数第k个节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line">ListNode <span class="title function_">findFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论遍历一次链表和遍历两次链表的时间复杂度都是 O(N)，但上述这个算法更有技巧性,只需要遍历链表一次即可得出结果</p><h2 id="删除链表的倒数第n个节点"><a href="#删除链表的倒数第n个节点" class="headerlink" title="删除链表的倒数第n个节点"></a>删除链表的倒数第n个节点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">// 删除倒数第 n 个，要先找倒数第 n + 1 个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">x</span> <span class="operator">=</span> findFromEnd(dummy, n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 删掉倒数第 n 个节点</span></span><br><span class="line">    x.next = x.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">findFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 代码见上文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快慢指针技巧"><a href="#快慢指针技巧" class="headerlink" title="快慢指针技巧"></a>快慢指针技巧</h1><h2 id="单链表的中点"><a href="#单链表的中点" class="headerlink" title="单链表的中点"></a>单链表的中点</h2><p>我们让两个指针 <code>slow</code> 和 <code>fast</code> 分别指向链表头结点 <code>head</code>。<br><strong>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> 走到链表末尾时，<code>slow</code> 就指向了链表中点。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">//快慢指针初始化指向head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">//快指针走到末尾时候停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//慢指针指向中点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">    <span class="comment">//需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h2><p>在以上<code>单链表的中点</code>代码的基础上稍作修改即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">    <span class="comment">// 快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a><br>完成了其中一种解法，通过将两条链表拼接在一起解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">null</span>) p1 = headB;</span><br><span class="line">        <span class="keyword">else</span>            p1 = p1.next;</span><br><span class="line">        <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="literal">null</span>) p2 = headA;</span><br><span class="line">        <span class="keyword">else</span>            p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种解法是：可以通过预先计算两条链表的长度来做到这一点，我在完成这一解发的过程中无法处理一种情况，<code>List1=[5,6,1,1,2,3]</code>,<code>List2=[4,1,1,2,3]</code>，而其中的<code>[1,2,3]</code>才是相交部分，先留着这个问题以后再来处理吧，但总算也是完成了一个小节了。  </p><p>第三种解法：如果把两条链表首尾相连，那么「寻找两条链表的交点」的问题转换成了前面讲的「寻找环起点」的问题。不过需要注意的是，这道题说不让你改变原始链表的结构，所以你把题目输入的链表转化成环形链表求解之后记得还要改回来，否则无法通过。</p><hr><p>目前已经完成<br><code>其中，除了合并排序链表不太会，其他都做的模模糊糊的了</code></p><table><thead><tr><th align="center">标题</th></tr></thead><tbody><tr><td align="center">左对齐</td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/linked-list-cycle/">141.环形链表</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142.环形链表 II</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160.相交链表</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19.删除链表的倒数第 N 个结点</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21.合并两个有序链表心</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23.合并K个升序链表心</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/partition-list/">86.分隔链表</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876.链表的中间结点</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22.链表中倒数第k个节点</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25.合并两个排序的链表</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52.两个链表的第一个公共节点</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/SLwz0R/">剑指 offer II 021.删除链表的倒数第 n 个结点G</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/c32eOV/">剑指 Offer II 022.链表中环的入口节点</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/3u1WK4/">剑指 offer II 023.两个链表的第一个重合节点</a></td></tr><tr><td align="center"><a href="https://leetcode.cn/problems/vvXgSW/">剑指 Offer II 078.合并排序链表</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手实现数组与链表算法</title>
      <link href="/2023/08/04/suanfa/arraylist_linkedlist/"/>
      <url>/2023/08/04/suanfa/arraylist_linkedlist/</url>
      
        <content type="html"><![CDATA[<p>还是买了算法课<br>拖了好几天，只跟着视频写了链表和数组的内置基本方法</p><h2 id="arraylist"><a href="#arraylist" class="headerlink" title="arraylist"></a>arraylist</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 真正存储数据的底层数组</span></span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="comment">// 记录当前元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 默认初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INIT_CAP</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(INIT_CAP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyArrayList</span><span class="params">(<span class="type">int</span> initCapacity)</span> &#123;</span><br><span class="line">        data = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[initCapacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E e)</span> &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        System.arraycopy(data,index,data,index+<span class="number">1</span>,size-index);</span><br><span class="line">        data[index] = e;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length == size)&#123;</span><br><span class="line">            resize(data.length * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[size] = e;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        add(<span class="number">0</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> data[index];</span><br><span class="line"></span><br><span class="line">        System.arraycopy(data,index+<span class="number">1</span>,data,index,size-index-<span class="number">1</span>);</span><br><span class="line">        data[size-<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &lt; data.length / <span class="number">4</span>)&#123;</span><br><span class="line">            resize(data.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">deletedval</span> <span class="operator">=</span> data[size-<span class="number">1</span>];</span><br><span class="line">        data[size-<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> deletedval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> data[index];</span><br><span class="line">        data[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工具方法</span></span><br><span class="line">    <span class="comment">// 将 data 的容量改为 newCap</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCap)</span> &#123;</span><br><span class="line">        E[] temp = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newCap];</span><br><span class="line">        System.arraycopy(data,<span class="number">0</span>,temp,<span class="number">0</span>,size);</span><br><span class="line">        data = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="linkedlist双链表"><a href="#linkedlist双链表" class="headerlink" title="linkedlist双链表"></a>linkedlist双链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 虚拟头尾节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> Node&lt;E&gt; head, tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双链表节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E val;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(E val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数初始化头尾节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 增 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(e);</span><br><span class="line">        Node&lt;E&gt; temp = tail.prev;</span><br><span class="line">        <span class="comment">//temp &lt;-&gt;tail</span></span><br><span class="line">        temp.next = x;</span><br><span class="line">        tail.prev = x;</span><br><span class="line">        x.next = tail;</span><br><span class="line">        x.prev = temp;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(e);</span><br><span class="line">        Node&lt;E&gt; temp = head.next;</span><br><span class="line"></span><br><span class="line">        temp.prev = x;</span><br><span class="line">        x.next = temp;</span><br><span class="line"></span><br><span class="line">        head.next = x;</span><br><span class="line">        x.prev = head;</span><br><span class="line"></span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        <span class="keyword">if</span> (index == size)&#123;</span><br><span class="line">            addLast(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Node&lt;E&gt; P = getNode(index);</span><br><span class="line">            Node&lt;E&gt; temp = P.prev;</span><br><span class="line">            <span class="comment">//temp &lt;-&gt; P</span></span><br><span class="line">            Node&lt;E&gt; x = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);</span><br><span class="line">            temp.next = x;</span><br><span class="line">            x.prev = temp;</span><br><span class="line"></span><br><span class="line">            P.prev = x;</span><br><span class="line">            x.next = P;</span><br><span class="line">         &#125;</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 删 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; x = head.next;</span><br><span class="line">        Node&lt;E&gt; temp = x.next;</span><br><span class="line">        <span class="comment">//head &lt;-&gt; x &lt;-&gt; temp</span></span><br><span class="line">        head.next = temp;</span><br><span class="line">        temp.prev = head;</span><br><span class="line"></span><br><span class="line">        x.next = x.prev = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size&lt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; x= tail.prev;</span><br><span class="line">        Node&lt;E&gt; temp = x.prev;</span><br><span class="line">        <span class="comment">//temp x tail</span></span><br><span class="line">        temp.next = tail;</span><br><span class="line">        tail.prev = temp;</span><br><span class="line">        x.prev = x.next = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; p = getNode(index);</span><br><span class="line">        Node&lt;E&gt; prev = p.prev;</span><br><span class="line">        Node&lt;E&gt; next = p.next;</span><br><span class="line">        <span class="comment">//prev p next</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 查 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; p = getNode(index);</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tail.prev.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 改 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E val)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; p = getNode(index);</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> p.val;</span><br><span class="line">        p.val = val;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="linkedlist单链表"><a href="#linkedlist单链表" class="headerlink" title="linkedlist单链表"></a>linkedlist单链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignalLinkedList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 虚拟头尾节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> Node&lt;E&gt; head, tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单链表节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E val;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数初始化头尾节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SignalLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 增 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(e);</span><br><span class="line">        Node&lt;E&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (size - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            temp = getNode(size-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// temp tail</span></span><br><span class="line">        x.next = tail;</span><br><span class="line">        temp.next = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(e);</span><br><span class="line">        Node&lt;E&gt; temp = head.next;</span><br><span class="line">        <span class="comment">//head temp</span></span><br><span class="line">        x.next = temp;</span><br><span class="line">        head.next = x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);</span><br><span class="line">        Node&lt;E&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (size-<span class="number">1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            temp = getNode(index-<span class="number">1</span>);</span><br><span class="line">            Node&lt;E&gt; next = temp.next;</span><br><span class="line">            <span class="comment">//temp next</span></span><br><span class="line">            x.next = next;</span><br><span class="line">            temp.next = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp=head;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 删 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; x = head.next;</span><br><span class="line">        Node&lt;E&gt; temp = x.next;</span><br><span class="line">        <span class="comment">//head x temp</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.val;</span><br><span class="line">        head.next = temp;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; x = getNode(size - <span class="number">1</span>);</span><br><span class="line">        Node&lt;E&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (size - <span class="number">2</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            temp = getNode(size - <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// temp -&gt; x -&gt; tail</span></span><br><span class="line">        temp.next = tail;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// temp -&gt; tail</span></span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = getNode(index);</span><br><span class="line">        Node&lt;E&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (index - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            temp = getNode(index - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// temp -&gt; x -&gt; tail</span></span><br><span class="line">        temp.next = x.next;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// temp -&gt; tail</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 查 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = getNode(index);</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;E&gt; x = getNode(size-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***** 改 *****/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E val)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = getNode(index);</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldval</span> <span class="operator">=</span> x.val;</span><br><span class="line">        x.val = val;</span><br><span class="line">        <span class="keyword">return</span> oldval;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>到这里还有一个任务没做，就是用<code>双链表的形式实现栈和队列的一些方法</code>，看了一下不难，但实在是不想做了，这也是我的一个毛病。。。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法Day1(补基础)</title>
      <link href="/2023/07/29/suanfa/suanfa1/"/>
      <url>/2023/07/29/suanfa/suanfa1/</url>
      
        <content type="html"><![CDATA[<p>今天重新看回来时候，发现已经几乎全忘了，而且第一次学的时候用的是c语言，这次想用java，在语法和描述方面，也有一些不一样。</p><h1 id="会用到的基本类型以及初始化的方法"><a href="#会用到的基本类型以及初始化的方法" class="headerlink" title="会用到的基本类型以及初始化的方法"></a>会用到的基本类型以及初始化的方法</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>,n = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 初始化一个大小为 10 的 int 数组</span></span><br><span class="line"><span class="comment">// 其中的值默认初始化为 0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">one</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="comment">// 初始化一个大小为 10 的 int 数组</span></span><br><span class="line"><span class="comment">// 其中的值默认初始化为 0</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m]</span><br></pre></td></tr></table></figure><h2 id="2-字符串String"><a href="#2-字符串String" class="headerlink" title="2. 字符串String"></a>2. 字符串<code>String</code></h2><p>由于Java不允许直接使用<code>[]</code>访问与修改其中的字符，所以要通过函数转换成<code>char[]</code>类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line"><span class="comment">//获取字符&#x27;e&#x27;</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s1.charAt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改字符串，以下输出结果为：hallo，world</span></span><br><span class="line"><span class="type">char</span>[] chars = s1.toCharArray();</span><br><span class="line">chars[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">s1 = <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">System.out.println(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过equals方法判断字符串是否相同</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars)</span><br><span class="line"><span class="keyword">if</span>(s1.equals(s2))&#123;</span><br><span class="line">    <span class="comment">//s1与s2相同</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//s1与s2不同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串可以通过&#x27;+&#x27;拼接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">System.out.println(s3);</span><br></pre></td></tr></table></figure><p>此外，若需要频繁的字符串拼接，用<code>+</code>的效率并不高，推荐使用StringBuilder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; ch &lt; <span class="string">&#x27;f&#x27;</span> ; ch++)&#123;</span><br><span class="line">    sb.append(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sb.append(g).append(hij).append(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> sb.toString();</span><br><span class="line"><span class="comment">//以下输出为：abcdefghij123</span></span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><h2 id="3-动态数组"><a href="#3-动态数组" class="headerlink" title="3. 动态数组"></a>3. 动态数组</h2><p>由于数组的特性，导致存储时并不安全，我们可以通过动态数组<code>ArrayList</code>以及泛型<code>&lt;&gt;</code>，来构造动态数组以及限制元素类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个String类型的动态数组</span></span><br><span class="line">ArrayList&lt;String&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//初始化一个int类型的动态数组</span></span><br><span class="line">ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>常用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//返回数组中元素的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//返回索引的index元素（2023.7.29，不太明白）</span></span><br><span class="line">E <span class="title function_">get</span> <span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="comment">//在数组尾部添加元素e</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br></pre></td></tr></table></figure><h2 id="4-双链表"><a href="#4-双链表" class="headerlink" title="4. 双链表"></a>4. 双链表</h2><p><code>Arraylist</code>的底层是数组,<code>Linklist</code>的底层是双链表,其初始方法类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个int类型的双链表</span></span><br><span class="line">LinkedList&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//初始化一个strings类型的双链表</span></span><br><span class="line">LinkedList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>常用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"><span class="comment">//返回链表中的元素个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="comment">//判断是否包含元素o</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span></span><br><span class="line"><span class="comment">//在链表尾部添加元素e</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span></span><br><span class="line"><span class="comment">//在链表尾部添加元素e</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span></span><br><span class="line"><span class="comment">//在链表头部添加元素e</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addFiest</span><span class="params">(E e)</span></span><br><span class="line"><span class="comment">//移除链表头部的元素</span></span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span></span><br><span class="line"><span class="comment">//移除链表尾部的元素</span></span><br><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>与<code>ArrayList</code>不同,我们更多用<code>Linkedlist</code>进行头尾操作,因为其底层数据结构为链表,直接操作头尾效率较高.其中只有<code>contains</code>方法时间复杂度为<code>O(N)</code>,因为其需要把整个链表遍历一遍</p><hr><p>2023.7.30 22:24分看完,效率有点低,下午搞了一下午blog的bug和音乐插件,现在准备看链表算法的视频</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>md语法文档+部分功能测试</title>
      <link href="/2023/07/27/trypost/"/>
      <url>/2023/07/27/trypost/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天把大概的都配好啦</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wow</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新建文章命令："><a href="#新建文章命令：" class="headerlink" title="新建文章命令："></a>新建文章命令：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;article title&quot;</span><br></pre></td></tr></table></figure><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>以下内容参考自selfsudo的博客<br>原文作者： selfsudo<br>原文链接： <a href="http://selfsudo.github.io/2019/07/14/%E5%9C%A8%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E5%86%99%E5%8D%9A%E5%AE%A2%E5%8F%8AMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/">http://selfsudo.github.io/2019/07/14/在个人网站写博客及Markdown基本语法使用/</a></p><h2 id="1-斜体，粗体，删除线"><a href="#1-斜体，粗体，删除线" class="headerlink" title="1. 斜体，粗体，删除线"></a>1. 斜体，粗体，删除线</h2><p>写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*这是斜体* 或 _这也是斜体_</span><br><span class="line">**这是粗体**</span><br><span class="line">***这是加粗斜体***</span><br><span class="line">~~这是删除线~~</span><br></pre></td></tr></table></figure><p>效果：<br><em>这是斜体</em> 或 <em>这也是斜体</em><br><strong>这是粗体</strong><br><em><strong>这是加粗斜体</strong></em><br><del>这是删除线</del>  </p><h2 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h2><p>写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line">共六个级别的标题</span><br></pre></td></tr></table></figure><p>效果</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>标题显示有#，应该是最初的配置文件有问题，调了一整天终于调好了，真是讨厌</p><h2 id="3-图片"><a href="#3-图片" class="headerlink" title="3. 图片"></a>3. 图片</h2><p>写法：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](图片地址)</span><br><span class="line">例如：![网络图片——陈奕迅](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2989782649,1389878803&amp;fm=58&amp;bpow=1200&amp;bpoh=1600)</span><br></pre></td></tr></table></figure><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2989782649,1389878803&fm=58&bpow=1200&bpoh=1600" alt="文字描述"></p><h1 id="html写法，可调整图片属性"><a href="#html写法，可调整图片属性" class="headerlink" title="html写法，可调整图片属性"></a>html写法，可调整图片属性</h1><div style="text-align: center;"><img src="https://z4a.net/images/2023/08/03/IMG_1495.jpg" alt="Oi22bX.jpg"  ></div><h2 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4. 无序列表"></a>4. 无序列表</h2><p>写法：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 无序列表第一种方法</span><br><span class="line">+ 无序列表第二种方法</span><br><span class="line">- 无序列表第三种方法</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>无序列表第一种方法</li></ul><ul><li>无序列表第二种方法</li></ul><ul><li>无序列表第三种方法</li></ul><p><strong>无序嵌套</strong></p><p>写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 第一级</span><br><span class="line">  * 第二级</span><br><span class="line">    * 第三级</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li>第一级<ul><li>第二级<ul><li>第三级</li></ul></li></ul></li></ul><h2 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h2><p>以后的我也应该会</p><h2 id="6-嵌套分级"><a href="#6-嵌套分级" class="headerlink" title="6. 嵌套分级"></a>6. 嵌套分级</h2><p>写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;第一级</span><br><span class="line">&gt;&gt;第二级</span><br><span class="line">&gt;&gt;&gt;第三级</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>第一级</p><blockquote><p>第二级</p><blockquote><p>第三级</p></blockquote></blockquote></blockquote><h2 id="7-分界线"><a href="#7-分界线" class="headerlink" title="7. 分界线"></a>7. 分界线</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><hr><h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h2><p>写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|表头1|表头2|表头3|表头4|</span><br><span class="line">|-| :- | :-: | -:|</span><br><span class="line">|默认左对齐|设置左对齐|设置居中对齐|设置右对齐|</span><br><span class="line">|左对齐|左对齐|居中对齐|右对齐|</span><br><span class="line">|左对齐|左对齐|居中对齐|右对齐|</span><br></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th>表头1</th><th align="left">表头2</th><th align="center">表头3</th><th align="right">表头4</th></tr></thead><tbody><tr><td>默认左对齐</td><td align="left">设置左对齐</td><td align="center">设置居中对齐</td><td align="right">设置右对齐</td></tr><tr><td>左对齐</td><td align="left">左对齐</td><td align="center">居中对齐</td><td align="right">右对齐</td></tr><tr><td>左对齐</td><td align="left">左对齐</td><td align="center">居中对齐</td><td align="right">右对齐</td></tr></tbody></table><h2 id="9-首行缩进"><a href="#9-首行缩进" class="headerlink" title="9. 首行缩进"></a>9. 首行缩进</h2><p>写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;ensp;</span><br></pre></td></tr></table></figure><p>效果<br>&ensp;&ensp;看这个缩进</p><h2 id="10-字体"><a href="#10-字体" class="headerlink" title="10. 字体"></a>10. 字体</h2><p>字体款式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;</span><br></pre></td></tr></table></figure><p>效果：<br><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font>  </p><p>字体颜色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=red&gt;我是红色&lt;/font&gt;</span><br><span class="line">&lt;font color=#008000&gt;我是绿色&lt;/font&gt;</span><br><span class="line">&lt;font color=Blue&gt;我是蓝色&lt;/font&gt;</span><br></pre></td></tr></table></figure><p>效果：<br><font color=red>我是红色</font><br><font color=#008000>我是绿色</font><br><font color=Blue>我是蓝色</font>  </p><p>字体大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;font size=4&gt;我是尺寸4&lt;/font&gt;</span><br><span class="line">&lt;font size=5&gt;我是尺寸5&lt;/font&gt;</span><br><span class="line">&lt;font size=6&gt;我是尺寸6&lt;/font&gt;</span><br></pre></td></tr></table></figure><h2 id="11-高亮"><a href="#11-高亮" class="headerlink" title="11. 高亮"></a>11. 高亮</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mark&gt;&lt;/mark&gt;</span><br></pre></td></tr></table></figure><p>这是一段<mark>高亮提醒</mark><br>butterfly高亮代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">臣亮言：&#123;% label 先帝 %&#125;創業未半，而&#123;% label 中道崩殂 blue %&#125;。今天下三分，&#123;% label 益州疲敝 pink %&#125;，此誠&#123;% label 危急存亡之秋 red %&#125;也！然侍衞之臣，不懈於內；&#123;% label 忠志之士 purple %&#125;，忘身於外者，蓋追先帝之殊遇，欲報之於陛下也。誠宜開張聖聽，以光先帝遺德，恢弘志士之氣；不宜妄自菲薄，引喻失義，以塞忠諫之路也。</span><br><span class="line">宮中、府中，俱為一體；陟罰臧否，不宜異同。若有&#123;% label 作奸 orange %&#125;、&#123;% label 犯科 green %&#125;，及為忠善者，宜付有司，論其刑賞，以昭陛下平明之治；不宜偏私，使內外異法也。</span><br></pre></td></tr></table></figure><p>效果:<br>臣亮言：<mark class="hl-label default">先帝</mark> 創業未半，而<mark class="hl-label blue">中道崩殂</mark> 。今天下三分，<mark class="hl-label pink">益州疲敝</mark> ，此誠<mark class="hl-label red">危急存亡之秋</mark> 也！然侍衞之臣，不懈於內；<mark class="hl-label purple">忠志之士</mark> ，忘身於外者，蓋追先帝之殊遇，欲報之於陛下也。誠宜開張聖聽，以光先帝遺德，恢弘志士之氣；不宜妄自菲薄，引喻失義，以塞忠諫之路也。<br>宮中、府中，俱為一體；陟罰臧否，不宜異同。若有<mark class="hl-label orange">作奸</mark> 、<mark class="hl-label green">犯科</mark> ，及為忠善者，宜付有司，論其刑賞，以昭陛下平明之治；不宜偏私，使內外異法也。</p><h2 id="测试deplayer"><a href="#测试deplayer" class="headerlink" title="测试deplayer"></a>测试deplayer</h2><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"video":{"url":"/img/fengmian/test.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=red&gt;妈的怎么这么难配，全是bug&lt;/font&gt;  </span><br><span class="line">终于给我钻研出来了，视频成功上传到了github，找到路径链接复制，通过以下代码粘贴  </span><br><span class="line"></span><br></pre></td></tr></table></figure><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"video":{"url":"[/img/video/cangjie.mp4](https://github.com/augensturn030217/augensturn030217.github.io/blob/main/img/video/cangjie.mp4)"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label 第二天睡醒就不行了 red %&#125;</span><br></pre></td></tr></table></figure><h2 id="note功能（flat为例子）"><a href="#note功能（flat为例子）" class="headerlink" title="note功能（flat为例子）"></a>note功能（flat为例子）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;</span><br><span class="line">默認 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;</span><br><span class="line">default 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;</span><br><span class="line">primary 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;</span><br><span class="line">success 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;</span><br><span class="line">info 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;</span><br><span class="line">warning 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;</span><br><span class="line">danger 提示塊標籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note flat"><p>默認 提示塊標籤</p></div><div class="note default flat"><p>default 提示塊標籤</p></div><div class="note primary flat"><p>primary 提示塊標籤</p></div><div class="note success flat"><p>success 提示塊標籤</p></div><div class="note info flat"><p>info 提示塊標籤</p></div><div class="note warning flat"><p>warning 提示塊標籤</p></div><div class="note danger flat"><p>danger 提示塊標籤</p></div>]]></content>
      
      
      <categories>
          
          <category> try </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 尝试 </tag>
            
            <tag> 语法 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2023/07/25/article-title/"/>
      <url>/2023/07/25/article-title/</url>
      
        <content type="html"><![CDATA[<p>测试一下第一篇blog</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/25/hello-world/"/>
      <url>/2020/07/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
